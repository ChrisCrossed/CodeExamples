class Z_TutorialLogic_2 : ZilchComponent
{
    sends IncrementScore : Event;
    sends IncrementBoosts : Event;
    sends DecrementBoosts : Event;
    
    // Set the level's height and width
    [Property]
    var I_LevelWidth:Integer = 16;
    [Property]
    var I_LevelHeight:Integer = 10;
    
    [Property]
    var R_BLOCK_TIMER_SECONDS:Real = 0.75;
    
    var R_Timer:Real = 0;
    var R_ButtonTimer:Real = 0;
    
    var Rand:Random = new Random();
    
    var ArchBlock:Archetype = Archetype.Find("Block");
    
    var BoardGrid:Array[Array[Cog]] = new Array[Array[Cog]]();
    var PathfindingArray:Array[Real2] = new Array[Real2]();
    var ScoreArray:Array[Real2] = new Array[Real2]();
    var B_FoundSolution:Boolean = false;
    
    var B_AllowedToCheck:Boolean = true;
    var B_AllowedToMoveBlocks:Boolean = true;
    
    var I_RecCheck:Integer = 0;
    
    var I_Score:Integer = 0;
    var I_TurnCount:Integer = 0;
    
    [Property]
    var I_NumBoosts:Integer = 3;
    [Property]
    var ScoreToAddBoost:Integer = 250;
    
    var ScoreCheck:Integer = 0;
    
    var PauseReason:Enum_PauseReason = Enum_PauseReason.GameBegin;
    
    var B_BoostUsed:Boolean = false;
    var BoostType:Enum_BlockType = Enum_BlockType.None;
    var BoostArray:Array[Real2] = new Array[Real2]();
    
    // Game Over block X/Y
    var I_GO_X:Integer = 0;
    var I_GO_Y:Integer = 0;
    
    var I_PathfindingCheck:Integer = 0;
    
    function Initialize(init : CogInitializer)
    {
        this.CreateWalls();
        
        // Generate the board (Y Axis)
        for(var y = 0; y < this.I_LevelHeight; ++y)
        {
            this.BoardGrid.Add(new Array[Cog]());
        }
        
        // Generate the board (X Axis)
        for(var y = 0; y < this.I_LevelHeight; ++y)
        {
            for(var x = 0; x < this.I_LevelWidth; ++x)
            {
                // Get the Y first, then set the X
                var archBlock = this.Space.CreateAtPosition(Archetype.Find("Block"), Real3(x + 0.5, y + 0.5, 0));
                archBlock.Z_BlockLogic.BlockType = Enum_BlockType.None;
                this.BoardGrid.Get(y).Push(archBlock);
            }
        }
        
        this.PopulateTutorialLevel();
        
        this.Create2x2();
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        Zero.Connect(this.GameSession, Events.GameRequestQuit, this.OnGameRequestQuit);
    }
    
    function OnGameRequestQuit(gameEvent : GameEvent)
    {
        Console.WriteLine("ESC Pressed");
        this.Space.LoadLevel(Level.Find("Menu_MainMenu"));
        gameEvent.Handled = true;
    }
    
    function PopulateTutorialLevel()
    {
        for(var k = 0; k < 4; ++k)
        {
            if(k == 0)
            {
                // Bottom Row
                for(var i = 0; i < this.I_LevelWidth; ++i) // Block One Red, Two Blue
                {
                    if(i <= this.I_LevelWidth - 3)
                    {
                        this.BoardGrid.Get(k).Get(i).Z_BlockLogic.BlockType = Enum_BlockType.Block_One_Static;
                    }
                    else
                    {
                        this.BoardGrid.Get(k).Get(i).Z_BlockLogic.BlockType = Enum_BlockType.Block_Two_Static;
                    }
                }
            }
            else if(k == 1)
            {
                // Second row
                for(var i = 0; i < this.I_LevelWidth; ++i)
                {
                    if(i <= 8 || i == this.I_LevelWidth - 1)
                    {
                        this.BoardGrid.Get(k).Get(i).Z_BlockLogic.BlockType = Enum_BlockType.Block_One_Static;
                    }
                    else if(i == this.I_LevelWidth - 2)
                    {
                        this.BoardGrid.Get(k).Get(i).Z_BlockLogic.BlockType = Enum_BlockType.Block_Two_Static;
                    }
                }
            }
            else if(k == 2) // Third Row
            {
                for(var i = 0; i < this.I_LevelWidth; ++i)
                {
                    if(i < 2 || i == 7)
                    {
                        this.BoardGrid.Get(k).Get(i).Z_BlockLogic.BlockType = Enum_BlockType.Block_Two_Static;
                    }
                    else if(i == 4 || i == 5 || i == 6 || i == this.I_LevelWidth - 2 || i == this.I_LevelWidth - 1)
                    {
                        this.BoardGrid.Get(k).Get(i).Z_BlockLogic.BlockType = Enum_BlockType.Block_One_Static;
                    }
                }
            }
            else if(k == 3) // Top Row
            {
                for(var i = 0; i < this.I_LevelWidth; ++i)
                {
                    if(i >= 4 && i <= 7)
                    {
                        this.BoardGrid.Get(k).Get(i).Z_BlockLogic.BlockType = Enum_BlockType.Block_Two_Static;
                    }
                }
            }
        }
    }
//
    function CreateWalls()
    {
        // Create bottom wall
        for(var i = 0; i < this.I_LevelWidth; ++i)
        {
            this.Space.CreateAtPosition(Archetype.Find("Block_Ground"), Real3(i + 0.5, -0.5, 0));
        }
        
        // Create walls (Starting equal height of the ground
        for(var j = -1; j < this.I_LevelHeight; ++j)
        {
            // Creates left wall
            this.Space.CreateAtPosition(Archetype.Find("Block_Wall"), Real3(-0.5, j + 0.5, 0));
            
            // Creates right wall
            this.Space.CreateAtPosition(Archetype.Find("Block_Wall"), Real3(this.I_LevelWidth + 0.5, j + 0.5, 0));
        }
    }
    
//
    function Create2x2()
    {
        // First, check to see any of the dead center top pieces are empty
        if( this.BoardGrid.Get(this.I_LevelHeight - 1).Get((this.I_LevelWidth / 2) - 1).Z_BlockLogic.BlockType == Enum_BlockType.None   || 
            this.BoardGrid.Get(this.I_LevelHeight - 1).Get(this.I_LevelWidth / 2).Z_BlockLogic.BlockType == Enum_BlockType.None         || 
            this.BoardGrid.Get(this.I_LevelHeight - 2).Get((this.I_LevelWidth / 2) - 1).Z_BlockLogic.BlockType == Enum_BlockType.None   || 
            this.BoardGrid.Get(this.I_LevelHeight - 2).Get(this.I_LevelWidth / 2).Z_BlockLogic.BlockType == Enum_BlockType.None          )
            {
                // If they are empty, randomly set the four positions to be an active piece
                for(var i = 0; i <= 4; ++i)
                {
                    // Get an arbitrary block
                    var testBlock = this.BoardGrid.Get(this.I_LevelHeight - 1).Get((this.I_LevelWidth / 2) - 1);
                    
                    // if(this.I_Score == 0)
                    // {
                    if(i == 1)
                    {
                        testBlock.Z_BlockLogic.BlockType = Enum_BlockType.Block_One_Active;
                    }
                    else if(i == 2)
                    {
                        testBlock = this.BoardGrid.Get(this.I_LevelHeight - 1).Get(this.I_LevelWidth / 2);
                        testBlock.Z_BlockLogic.BlockType = Enum_BlockType.Block_Two_Active;
                    }
                    else if(i == 3)
                    {
                        testBlock = this.BoardGrid.Get(this.I_LevelHeight - 2).Get((this.I_LevelWidth / 2) - 1);
                        testBlock.Z_BlockLogic.BlockType = Enum_BlockType.Block_Two_Active;
                    }
                    else if(i == 4)
                    {
                        testBlock = this.BoardGrid.Get(this.I_LevelHeight - 2).Get(this.I_LevelWidth / 2);
                        testBlock.Z_BlockLogic.BlockType = Enum_BlockType.Block_Two_Active;
                    }
                    
                    
                    /*
                    if(this.Rand.CoinFlip())
                    {
                        testBlock.Z_BlockLogic.BlockType = Enum_BlockType.Block_One_Active;
                    }
                    else
                    {
                        testBlock.Z_BlockLogic.BlockType = Enum_BlockType.Block_Two_Active;
                        // testBlock.Z_BlockLogic.BlockType = Enum_BlockType.Block_One_Active;
                    } */
                    
                } // End ForLoop
            } // End If
        
            
        // If not empty, re-populate the top four with random static blocks
        else
        {
            // If they are empty, randomly set the four positions to be an active piece
            for(var i = 0; i <= 4; ++i)
            {
                // Get an arbitrary block
                var testBlock = this.BoardGrid.Get(this.I_LevelHeight - 1).Get((this.I_LevelWidth / 2) - 1);
                var runTest = false;
                
                if(i == 1 && this.BoardGrid.Get(this.I_LevelHeight - 1).Get((this.I_LevelWidth / 2) - 1).Z_BlockLogic.BlockType == Enum_BlockType.None)
                {
                    runTest = true;
                }
                else if(i == 2 && this.BoardGrid.Get(this.I_LevelHeight - 1).Get(this.I_LevelWidth / 2).Z_BlockLogic.BlockType == Enum_BlockType.None)
                {
                    testBlock = this.BoardGrid.Get(this.I_LevelHeight - 1).Get(this.I_LevelWidth / 2);
                    runTest = true;
                }
                else if(i == 3 && this.BoardGrid.Get(this.I_LevelHeight - 2).Get((this.I_LevelWidth / 2) - 1).Z_BlockLogic.BlockType == Enum_BlockType.None)
                {
                    testBlock = this.BoardGrid.Get(this.I_LevelHeight - 2).Get((this.I_LevelWidth / 2) - 1);
                    runTest = true;
                }
                else if(i == 4 && this.BoardGrid.Get(this.I_LevelHeight - 2).Get(this.I_LevelWidth / 2).Z_BlockLogic.BlockType == Enum_BlockType.None)
                {
                    testBlock = this.BoardGrid.Get(this.I_LevelHeight - 2).Get(this.I_LevelWidth / 2);
                    runTest = true;
                }
                
                if(runTest)
                {
                    if(this.Rand.CoinFlip())
                    {
                        testBlock.Z_BlockLogic.BlockType = Enum_BlockType.Block_One_Static;
                    }
                    else
                    {
                        testBlock.Z_BlockLogic.BlockType = Enum_BlockType.Block_Two_Static;
                    }
                } // End 'If'-tests
            } // End ForLoop
            
            // Run EndGame
            this.PauseReason = Enum_PauseReason.GameOver;
        }
    }

//
    function AllBlocksStatic()
    {
        for(var x = 0; x < this.I_LevelWidth; ++x)
        {
            for(var y = 0; y < this.I_LevelHeight; ++y)
            {
                if(this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == Enum_BlockType.Block_One_Active)
                {
                    this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType = Enum_BlockType.Block_One_Static;
                }
                else if(this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == Enum_BlockType.Block_Two_Active)
                {
                    this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType = Enum_BlockType.Block_Two_Static;
                }
            }
        }
        
        this.ConsolidateBlocks();
        this.DetermineScoreLine();
        this.B_AllowedToCheck = true;
        this.Create2x2();
    }
//
    function GenerateActiveBlocksArray():Array[Real2]
    {
        // Find each coordinate of the Active blocks and put the coordinates into an array
        var activeArray:Array[Real2] = new Array[Real2]();
        for(var y = 0; y < this.I_LevelHeight; ++y)
        {
            for(var x = 0; x < this.I_LevelWidth; ++x)
            {
                if( this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == Enum_BlockType.Block_One_Active ||
                    this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == Enum_BlockType.Block_Two_Active  )
                    {
                        var currentPos:Real2 = Real2(x, y);
                        activeArray.Push(currentPos);
                    }
            }
        }
        
        return activeArray;
    }
//
    function MoveBlocks(moveDir : Enum_MoveDirection)
    {
        var activeArray = this.GenerateActiveBlocksArray();
        
        var canMoveLeft:Boolean = false;
        var canMoveRight:Boolean = false;
        
        // Determine if blocks to the right of our active array exist or not
        if( (activeArray.Get(0).X as Integer - 1) >= 0 &&
            (activeArray.Get(2).X as Integer - 1) >= 0 &&
            this.BoardGrid.Get(activeArray.Get(0).Y as Integer).Get(activeArray.Get(0).X as Integer - 1).Z_BlockLogic.BlockType == Enum_BlockType.None &&
            this.BoardGrid.Get(activeArray.Get(2).Y as Integer).Get(activeArray.Get(2).X as Integer - 1).Z_BlockLogic.BlockType == Enum_BlockType.None  )
            {
                canMoveLeft = true;
            }
            
        // Determine if blocks to the right of our active array exist or not
        if( (activeArray.Get(1).X as Integer + 1) < this.I_LevelWidth &&
            (activeArray.Get(3).X as Integer + 1) < this.I_LevelWidth &&
            this.BoardGrid.Get(activeArray.Get(1).Y as Integer).Get(activeArray.Get(1).X as Integer + 1).Z_BlockLogic.BlockType == Enum_BlockType.None &&
            this.BoardGrid.Get(activeArray.Get(3).Y as Integer).Get(activeArray.Get(3).X as Integer + 1).Z_BlockLogic.BlockType == Enum_BlockType.None   )
            {
                canMoveRight = true;
            }
        
        // Depending on whether we are going left/down or right, we cycle through and shift the blocks in order (or reverse order) depending on the array.
        for(var i = 0; i < activeArray.Count; ++i)
        {
            // Determine what direction we need to move
            if(moveDir == Enum_MoveDirection.Down)
            {
                // Check to see if the spot below exists
                if( activeArray.Get(i).Y > 0 &&
                    this.BoardGrid.Get(activeArray.Get(i).Y as Integer - 1).Get(activeArray.Get(i).X as Integer).Z_BlockLogic.BlockType == Enum_BlockType.None)
                {
                    var arrayPos = activeArray.Get(i);
                    var currentPos = this.BoardGrid.Get(arrayPos.Y as Integer).Get(arrayPos.X as Integer);
                    this.BoardGrid.Get(arrayPos.Y as Integer - 1).Get(arrayPos.X as Integer).Z_BlockLogic.BlockType = currentPos.Z_BlockLogic.BlockType;
                    this.BoardGrid.Get(arrayPos.Y as Integer).Get(arrayPos.X as Integer).Z_BlockLogic.BlockType = Enum_BlockType.None;
                }
                else // We turn all bricks into Static
                {
                    this.AllBlocksStatic();
                    this.R_Timer = 0;
                    break;
                }
                this.R_Timer = 0;
            }
            else if(moveDir == Enum_MoveDirection.Left && canMoveLeft)
            {
                if( activeArray.Get(i).X as Integer > 0 &&
                this.BoardGrid.Get(activeArray.Get(i).Y as Integer).Get(activeArray.Get(i).X as Integer - 1).Z_BlockLogic.BlockType == Enum_BlockType.None)
                {
                    var arrayPos = activeArray.Get(i);
                    var currentPos = this.BoardGrid.Get(arrayPos.Y as Integer).Get(arrayPos.X as Integer);
                    this.BoardGrid.Get(arrayPos.Y as Integer).Get(arrayPos.X as Integer - 1).Z_BlockLogic.BlockType = currentPos.Z_BlockLogic.BlockType;
                    this.BoardGrid.Get(arrayPos.Y as Integer).Get(arrayPos.X as Integer).Z_BlockLogic.BlockType = Enum_BlockType.None;
                }
            }
            else if(moveDir == Enum_MoveDirection.Right && canMoveRight)
            {
                // recording the REVERSE ORDER of the array of blocks to move
                var j = (activeArray.Count - 1) - i;
                if( (activeArray.Get(j).X < (this.I_LevelWidth - 1) ) &&
                    this.BoardGrid.Get(activeArray.Get(j).Y as Integer).Get(activeArray.Get(j).X as Integer + 1).Z_BlockLogic.BlockType == Enum_BlockType.None)
                    {
                        var arrayPos = activeArray.Get(j);
                        var currentPos = this.BoardGrid.Get(arrayPos.Y as Integer).Get(arrayPos.X as Integer);
                        this.BoardGrid.Get(activeArray.Get(j).Y as Integer).Get(activeArray.Get(j).X as Integer + 1).Z_BlockLogic.BlockType = currentPos.Z_BlockLogic.BlockType;
                        this.BoardGrid.Get(activeArray.Get(j).Y as Integer).Get(activeArray.Get(j).X as Integer).Z_BlockLogic.BlockType = Enum_BlockType.None;
                    }
            }
            else if(!canMoveLeft && !canMoveRight)// We turn all bricks into Static
            {
                this.AllBlocksStatic();
                break;
            }
        }
    } // End MoveBlocks()
//
    function ConsolidateBlocks()
    {
        ++this.I_TurnCount;
        
        // We begin with X instead of Y so that we loop upward, not horizontally. (Imagine that we are pulling each column down, moving left to right)
        for(var x = 0; x < this.I_LevelWidth; ++x)
        {
            // Start on the 2nd layer since we aren't moving down the bottom layer
            for(var y = 1; y < this.I_LevelHeight; ++y)
            {
                // This function was called when we already know all blocks are static, so we can move blocks down.
                if( this.BoardGrid.Get(y - 1).Get(x).Z_BlockLogic.BlockType == Enum_BlockType.None  && 
                    (   this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == Enum_BlockType.Block_One_Static ||
                        this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == Enum_BlockType.Block_Two_Static) )
                    {
                        this.BoardGrid.Get(y - 1).Get(x).Z_BlockLogic.BlockType = this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType;
                        this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType = Enum_BlockType.None;
                        
                        // Run the check again each time we find a block we need to move
                        // this.ConsolidateBlocks();
                        y = 0;
                    } // End If
            } // End For(x) loop
        } // End For(y) loop
        this.B_AllowedToCheck = true;
        this.B_AllowedToMoveBlocks = false;
    }
//
    function RotateBlocks(rotateCounterClock : Boolean)
    {
        // Store the current active block positions
        var activeArray = this.GenerateActiveBlocksArray();
        var manipulateArray:Array[Enum_BlockType] = new Array[Enum_BlockType]();
        for(var i = 0; i < 4; ++i)
        {
            manipulateArray.Push(this.BoardGrid.Get(activeArray.Get(i).Y as Integer).Get(activeArray.Get(i).X as Integer).Z_BlockLogic.BlockType);
        }
        
        // Rotate Counter-Clockwise
        if(rotateCounterClock)
        {
            // Bottom Left receives Top Left
            this.BoardGrid.Get(activeArray.Get(0).Y as Integer).Get(activeArray.Get(0).X as Integer).Z_BlockLogic.BlockType = manipulateArray.Get(2);
            
            // Top Left receives Top Right
            this.BoardGrid.Get(activeArray.Get(2).Y as Integer).Get(activeArray.Get(2).X as Integer).Z_BlockLogic.BlockType = manipulateArray.Get(3);
            
            // Top Right receives Bottom Right
            this.BoardGrid.Get(activeArray.Get(3).Y as Integer).Get(activeArray.Get(3).X as Integer).Z_BlockLogic.BlockType = manipulateArray.Get(1);
            
            // Bottom Right receives Bottom Left
            this.BoardGrid.Get(activeArray.Get(1).Y as Integer).Get(activeArray.Get(1).X as Integer).Z_BlockLogic.BlockType = manipulateArray.Get(0);
        }
        else
        {
            // Top Left receives Bottom Left
            this.BoardGrid.Get(activeArray.Get(2).Y as Integer).Get(activeArray.Get(2).X as Integer).Z_BlockLogic.BlockType = manipulateArray.Get(0);
            
            // Top Right receives Top Left
            this.BoardGrid.Get(activeArray.Get(3).Y as Integer).Get(activeArray.Get(3).X as Integer).Z_BlockLogic.BlockType = manipulateArray.Get(2);
            
            // Bottom Right receives Top Right
            this.BoardGrid.Get(activeArray.Get(1).Y as Integer).Get(activeArray.Get(1).X as Integer).Z_BlockLogic.BlockType = manipulateArray.Get(3);
            
            // Bottom Left receives Bottom Right
            this.BoardGrid.Get(activeArray.Get(0).Y as Integer).Get(activeArray.Get(0).X as Integer).Z_BlockLogic.BlockType = manipulateArray.Get(1);
        }
    }
    
    
//
    function DetermineScoreLine():Boolean
    {
        this.ScoreArray = new Array[Real2]();
        
        this.B_FoundSolution = false;
        
        // blockCheck is tested to ensure that the new block being the compared is not the same as the previous color
        // That way, we help the recursion checks not occur for *all* blocks, but only *new* blocks.
        var blockCheck:Enum_BlockType = Enum_BlockType.None;
        
        // Begin checking for a score line only if the left-most column has a block in it.
        for(var y = 0; y < this.I_LevelHeight; ++y)
        {
            if(blockCheck != this.BoardGrid.Get(y).Get(0).Z_BlockLogic.BlockType)
            {
                blockCheck = this.BoardGrid.Get(y).Get(0).Z_BlockLogic.BlockType;
                
                // Clear the array here since this is a brand new attempt to find a line
                this.PathfindingArray = new Array[Real2]();
                
                if( this.BoardGrid.Get(y).Get(0).Z_BlockLogic.BlockType == Enum_BlockType.Block_One_Static ||
                    this.BoardGrid.Get(y).Get(0).Z_BlockLogic.BlockType == Enum_BlockType.Block_Two_Static)
                    {
                        this.PathfindingArray.Push(Real2(0, y));
                        
                        if(this.ScoreLine(Enum_MoveDirection.Right))
                        {
                            return true;
                        }
                    }
            }
        }
        return false;
    }
//
    function ScoreLine(currDir : Enum_MoveDirection):Boolean
{
        // We need to initiate a check to ensure every line has at least one block in it first.
        for(var i = this.I_LevelWidth - 1; i >= 0; --i)
        {
            if(this.BoardGrid.Get(0).Get(i).Z_BlockLogic.BlockType == Enum_BlockType.None)
            {
                return false;
            }
        }
    
        // Start with the last position in the array
        var currPos:Real2 = this.PathfindingArray.Get(this.PathfindingArray.Count - 1);
        
        // Check the x coordinate of the current position to determine if we are done
        if(currPos.X == this.I_LevelWidth as Integer - 1)
        {
            for(var i = 0; i < this.PathfindingArray.Count; ++i)
            {
                this.ScoreArray.Push(this.PathfindingArray.Get(i));
            }
            
            this.ApplyScore(this.ScoreArray);
            
            this.PauseReason = Enum_PauseReason.ScoreLine;
            
            this.B_AllowedToCheck = true;
            
            return true;
        }
        else // We have determined that we need to continue down the line
        {
            var blockType = this.BoardGrid.Get(currPos.Y as Integer).Get(currPos.X as Integer).Z_BlockLogic.BlockType;
            
            // Begin the check process to determine what locations to check
            // Now that we have the initial position to check against, we find all touching locations
            var rightFilled:Boolean = false;
            var belowFilled:Boolean = false;
            var aboveFilled:Boolean = false;
            var leftFilled:Boolean  = false;
            
            // If the space to the right exists AND
            // If the space to the right has the same block type AND
            // We are searching anywhere but where we came from
            if( currPos.X as Integer + 1 < this.I_LevelWidth &&
                this.BoardGrid.Get(currPos.Y as Integer).Get(currPos.X as Integer + 1).Z_BlockLogic.BlockType == blockType &&
                currDir != Enum_MoveDirection.Left)
            {
                rightFilled = true;
            }
            
            // If the space below exists AND
            // If the space below has the same block type AND
            // We are searching anywhere but where we came from
            if( currPos.Y as Integer - 1 >= 0 &&
                this.BoardGrid.Get(currPos.Y as Integer - 1).Get(currPos.X as Integer).Z_BlockLogic.BlockType == blockType &&
                currDir != Enum_MoveDirection.Up)
            {
                belowFilled = true;
            }
            
            // If the space above exists AND
            // If the space above has the same block type AND
            // We are searching anywhere but where we came from
            if( (currPos.Y as Integer + 1) < this.I_LevelHeight &&
                this.BoardGrid.Get(currPos.Y as Integer + 1).Get(currPos.X as Integer).Z_BlockLogic.BlockType == blockType &&
                currDir != Enum_MoveDirection.Down)
            {
                aboveFilled = true;
            }
            
            
            // If the space to the left exists AND
            // If the space to the left has the same block type AND
            // We are searching anywhere but where we came from
            if( currPos.X as Integer - 1 >= 0 &&
                this.BoardGrid.Get(currPos.Y as Integer).Get(currPos.X as Integer - 1).Z_BlockLogic.BlockType == blockType &&
                currDir != Enum_MoveDirection.Right)
                {
                    leftFilled = true;
                }
                
            var shouldContinue = true;
                
            if(rightFilled)
            {
                var rightAbove:Real2 = Real2(currPos.X as Integer + 1, currPos.Y as Integer + 1);
                var rightBelow:Real2 = Real2(currPos.X as Integer + 1, currPos.Y as Integer - 1);
                
                // Check to see if the adjacent positions to the above spot are within the array EXCEPT the last position
                for(var i = 0; i < this.PathfindingArray.Count; ++i)
                {
                    if( this.PathfindingArray.Get(i) == rightAbove ||
                        this.PathfindingArray.Get(i) == rightBelow ) // Spot above and to the left lies within the array
                    {
                        // Console.WriteLine("At `currPos`, going `currDir`, problem at `this.PathfindingArray.Get(i)`");
                        // return false;
                        shouldContinue = false;
                    }
                }
                
                if(shouldContinue)
                {
                    this.PathfindingArray.Push(Real2(currPos.X as Integer + 1, currPos.Y as Integer));
                    
                    if(this.ScoreLine(Enum_MoveDirection.Right))
                    {
                        return true;
                    }
                }
            }
            
            shouldContinue = true;
            
            // Since the space below is populated, we need to check if it is within the array already
            if(belowFilled)
            {
                var belowLeft:Real2  = Real2(currPos.X as Integer - 1, currPos.Y as Integer - 1);
                var belowRight:Real2 = Real2(currPos.X as Integer + 1, currPos.Y as Integer - 1);
                
                // Check to see if the adjacent positions to the above spot are within the array EXCEPT the last position
                for(var i = 0; i < this.PathfindingArray.Count; ++i)
                {
                    if( this.PathfindingArray.Get(i) == belowLeft ||
                        this.PathfindingArray.Get(i) == belowRight ) // Spot above and to the left lies within the array
                    {
                        // Console.WriteLine("At `currPos`, going `currDir`, problem at `this.PathfindingArray.Get(i)`");
                        // return false;
                        shouldContinue = false;
                    }
                }
                
                if(shouldContinue)
                {
                    this.PathfindingArray.Push(Real2(currPos.X as Integer, currPos.Y as Integer - 1));
                    
                    if(this.ScoreLine(Enum_MoveDirection.Down))
                    {
                        return true;
                    }
                }
            }
            
            shouldContinue = true;
            
            if(aboveFilled)
            {
                var aboveLeft:Real2  = Real2(currPos.X as Integer - 1, currPos.Y as Integer + 1);
                var aboveRight:Real2 = Real2(currPos.X as Integer + 1, currPos.Y as Integer + 1);
                
                // Check to see if the adjacent positions to the above spot are within the array EXCEPT the last position
                for(var i = 0; i < this.PathfindingArray.Count; ++i)
                {
                    if( this.PathfindingArray.Get(i) == aboveLeft ||
                        this.PathfindingArray.Get(i) == aboveRight ) // Spot above and to the left lies within the array
                    {
                        shouldContinue = false;
                    }
                }
                
                if(shouldContinue)
                {
                    this.PathfindingArray.Push(Real2(currPos.X as Integer, currPos.Y as Integer + 1));
                    if(this.ScoreLine(Enum_MoveDirection.Up))
                    {
                        return true;
                    }
                }
            }
            
            shouldContinue = true;
            
            if(leftFilled)
            {
                var leftAbove:Real2 = Real2(currPos.X as Integer - 1, currPos.Y as Integer + 1);
                var leftBelow:Real2 = Real2(currPos.X as Integer - 1, currPos.Y as Integer - 1);
                
                // Check to see if the adjacent positions to the above spot are within the array EXCEPT the last position
                for(var i = 0; i < this.PathfindingArray.Count; ++i)
                {
                    if( this.PathfindingArray.Get(i) == leftAbove ||
                        this.PathfindingArray.Get(i) == leftBelow ) // Spot above and to the left lies within the array
                    {
                        // Console.WriteLine("At `currPos`, going `currDir`, problem at `this.PathfindingArray.Get(i)`");
                        shouldContinue = false;
                    }
                }
                
                if(shouldContinue)
                {
                    this.PathfindingArray.Push(Real2(currPos.X as Integer - 1, currPos.Y as Integer));
                    
                    if(this.ScoreLine(Enum_MoveDirection.Left))
                    {
                        return true;
                    }
                }
            }
        }
        this.PathfindingArray.Pop();
        
        return false;
    }

    
//
    function ApplyScore(scoreLine : Array[Real2])
    {
        // Decrementing TurnCount to keep correct count (Negates spare turns given by accident)
        --this.I_TurnCount;
        
        // Give the player score according to the length of the array
        this.I_Score += scoreLine.Count;
        
        for(var i = 0; i < scoreLine.Count; ++i)
        {
            this.GameSession.DispatchEvent("IncrementScore", new Event());
        }
        
        this.ScoreCheck += scoreLine.Count;
        
        for(var i = 0; i < (this.ScoreCheck / this.ScoreToAddBoost); ++i)
        {
            this.ScoreCheck -= this.ScoreToAddBoost;
            
            this.GameSession.DispatchEvent("IncrementBoosts", new Event());
            // this.Space.DispatchEvent(Events.IncrementBoosts, new Event());
            this.I_NumBoosts += 1;
        }
    }
    
//
    function ClearBoard(colorToKill : Enum_BlockType)
    {
        for(var y = 0; y < this.I_LevelHeight; ++y)
        {
            for(var x = 0; x < this.I_LevelWidth; ++x)
            {
                if(this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == colorToKill)
                {
                    this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType = Enum_BlockType.None;
                }
            }
        }
    }
//
    function ConvertBlocks(blockX : Integer, blockY : Integer)
    {
        this.BoardGrid.Get(blockY).Get(blockX).Z_BlockLogic.BlockType = Enum_BlockType.GameOver;
    }
//
    function OnLogicUpdate(event : UpdateEvent)
    {
        this.R_Timer += event.Dt;
        this.R_ButtonTimer += event.Dt;
        
        // Console.WriteLine(this.I_Score);
        
        var seq = Action.Sequence(this.Owner.Actions);
        var group = Action.Group(seq);
        
        var infoText_1 = this.Space.FindObjectByName("InfoText_1");
        var infoText_2a = this.Space.FindObjectByName("InfoText_2a");
        var infoText_2b = this.Space.FindObjectByName("InfoText_2b");
        var infoText_Lose = this.Space.FindObjectByName("InfoText_Lose");
        var infoText_Win = this.Space.FindObjectByName("InfoText_Win");
        
        var arrow_P2_2 = this.Space.FindObjectByName("Arrow_2,2");
        var arrow_P2_3 = this.Space.FindObjectByName("Arrow_2,3");
        var arrow_P3_2 = this.Space.FindObjectByName("Arrow_3,2");
        var arrow_P3_3 = this.Space.FindObjectByName("Arrow_3,3");
        var arrow_P8_3 = this.Space.FindObjectByName("Arrow_8,3");
        var arrow_P8_2 = this.Space.FindObjectByName("Arrow_8,2");
        var arrow_P9_2 = this.Space.FindObjectByName("Arrow_9,2");
        var arrow_P9_1 = this.Space.FindObjectByName("Arrow_9,1");
        
        var colorOn = Real4(0, 0, 0, 1);
        var colorOff = Real4(0, 0, 0, 0);
        
        // Setting the Arrow On colors
        var colorRedOn = arrow_P2_3.Sprite.Color;
        var colorBlueOn = arrow_P3_3.Sprite.Color;
        colorRedOn.W = 1;
        colorBlueOn.W = 1;
        
        // Setting the Arrow Off colors
        var colorRedOff = colorRedOn;
        var colorBlueOff = colorBlueOn;
        colorRedOff.W = 0;
        colorBlueOff.W = 0;
        
        if( this.BoardGrid.Get(3).Get(2).Z_BlockLogic.BlockType == Enum_BlockType.Block_One_Static && // Top Left, Red
            this.BoardGrid.Get(2).Get(3).Z_BlockLogic.BlockType == Enum_BlockType.Block_Two_Static  ) // Bottom Right, Blue
            {
                Action.Property(group, @arrow_P2_2.Sprite.Color, colorBlueOff, 0.2, Ease.Linear);
                Action.Property(group, @arrow_P2_3.Sprite.Color, colorRedOff, 0.2, Ease.Linear);
                Action.Property(group, @arrow_P3_2.Sprite.Color, colorBlueOff, 0.2, Ease.Linear);
                Action.Property(group, @arrow_P3_3.Sprite.Color, colorBlueOff, 0.2, Ease.Linear);
            }
            
        if( this.BoardGrid.Get(3).Get(8).Z_BlockLogic.BlockType == Enum_BlockType.Block_One_Static && // Top Left, Red
            this.BoardGrid.Get(1).Get(9).Z_BlockLogic.BlockType == Enum_BlockType.Block_Two_Static  ) // Bottom Right, Blue
            {
                Action.Property(group, @arrow_P8_2.Sprite.Color, colorBlueOff, 0.2, Ease.Linear);
                Action.Property(group, @arrow_P8_3.Sprite.Color, colorRedOff, 0.2, Ease.Linear);
                Action.Property(group, @arrow_P9_2.Sprite.Color, colorBlueOff, 0.2, Ease.Linear);
                Action.Property(group, @arrow_P9_1.Sprite.Color, colorBlueOff, 0.2, Ease.Linear);
            }
        
        if((this.I_TurnCount == 2 && this.I_Score == 0) || (this.I_TurnCount == 4 && this.I_Score != 28))
        {
            Action.Property(group, @infoText_1.SpriteText.Color, colorOff, 0.5, Ease.Linear);
            Action.Property(group, @infoText_2a.SpriteText.Color, colorOff, 0.5, Ease.Linear);
            Action.Property(group, @infoText_2b.SpriteText.Color, colorOff, 0.5, Ease.Linear);
            Action.Property(group, @infoText_Lose.SpriteText.Color, colorOn, 0.5, Ease.Linear);
            
            this.PauseReason = Enum_PauseReason.GameOver;
        }
        else if(this.I_TurnCount >= 2 && this.I_Score == 15)
        {
            Action.Property(group, @infoText_1.SpriteText.Color, colorOff, 0.5, Ease.Linear);
            Action.Property(group, @infoText_2a.SpriteText.Color, colorOn, 0.5, Ease.Linear);
            Action.Property(group, @infoText_2b.SpriteText.Color, colorOn, 0.5, Ease.Linear);
            Action.Property(group, @infoText_Lose.SpriteText.Color, colorOff, 0.5, Ease.Linear);
        }
        else if(this.I_Score == 28)
        {
            Action.Property(group, @infoText_1.SpriteText.Color, colorOff, 0.5, Ease.Linear);
            Action.Property(group, @infoText_2a.SpriteText.Color, colorOff, 0.5, Ease.Linear);
            Action.Property(group, @infoText_2b.SpriteText.Color, colorOff, 0.5, Ease.Linear);
            Action.Property(group, @infoText_Lose.SpriteText.Color, colorOff, 0.5, Ease.Linear);
            Action.Property(group, @infoText_Win.SpriteText.Color, colorOn, 0.5, Ease.Linear);
            
            // this.PauseReason = Enum_PauseReason.WinGame;
        }
        
        if(this.PauseReason == Enum_PauseReason.GameOver && this.R_Timer >= 3.0)
        {
            this.Space.ReloadLevel();
        }
        
        if(this.PauseReason == Enum_PauseReason.None) // Game is playing
        {
            if(this.B_AllowedToCheck)
            {
                this.B_AllowedToCheck = this.DetermineScoreLine();
            }
            
            if(this.R_Timer >= this.R_BLOCK_TIMER_SECONDS)
            {
                this.MoveBlocks(Enum_MoveDirection.Down);
                // Resetting the timer occurs within MoveBlocks
            }
            
            if(Zero.Keyboard.KeyIsPressed(Keys.Down) && this.B_AllowedToMoveBlocks)
            {
                this.MoveBlocks(Enum_MoveDirection.Down);
            }
            else if(Zero.Keyboard.KeyIsDown(Keys.Down) && this.B_AllowedToMoveBlocks)
            {
                if(this.R_ButtonTimer >= 0.3)
                {
                    this.MoveBlocks(Enum_MoveDirection.Down);
                }
            }
            else if(Zero.Keyboard.KeyIsPressed(Keys.Left) && this.B_AllowedToMoveBlocks)
            {
                this.MoveBlocks(Enum_MoveDirection.Left);
            }
            else if(Zero.Keyboard.KeyIsPressed(Keys.Right) && this.B_AllowedToMoveBlocks)
            {
                this.MoveBlocks(Enum_MoveDirection.Right);
            }
            else if(Zero.Keyboard.KeyIsPressed(Keys.Q))
            {
                this.RotateBlocks(true);
            }
            else if(Zero.Keyboard.KeyIsPressed(Keys.E))
            {
                this.RotateBlocks(false);
            }
            else if(Zero.Keyboard.KeyIsPressed(Keys.Up))
            {
                this.RotateBlocks(true);
            }
            else if(Zero.Keyboard.KeyIsPressed(Keys.Space))
            {
                this.AllBlocksStatic();
                this.R_Timer = 0;
            }
            else if(Zero.Keyboard.KeyIsDown(Keys.Left) && this.B_AllowedToMoveBlocks)
            {
                if(this.R_ButtonTimer >= 0.3)
                {
                    this.MoveBlocks(Enum_MoveDirection.Left);
                }
            }
            else if(Zero.Keyboard.KeyIsDown(Keys.Right) && this.B_AllowedToMoveBlocks)
            {
                if(this.R_ButtonTimer >= 0.3)
                {
                    this.MoveBlocks(Enum_MoveDirection.Right);
                }
            }
            else if(!Zero.Keyboard.KeyIsDown(Keys.Left) && !Zero.Keyboard.KeyIsDown(Keys.Right) && !Zero.Keyboard.KeyIsDown(Keys.Down))
            {
                this.R_ButtonTimer = 0;
                this.B_AllowedToMoveBlocks = true;
            }
            
            if(Zero.Keyboard.KeyIsPressed(Keys.A))
            {
                if(this.I_NumBoosts > 0)
                {
                    this.GameSession.DispatchEvent(Events.DecrementBoosts, new Event());
                    
                    this.PauseReason = Enum_PauseReason.BoostUsed;
                    this.BoostType = Enum_BlockType.Block_One_Static;
                    
                    this.BoostArray = new Array[Real2]();
                
                    // Create array of blocks to destroy
                    for(var y = 0; y < this.I_LevelHeight; ++y)
                    {
                        for(var x = 0; x < this.I_LevelWidth; ++x)
                        {
                            if(this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == this.BoostType)
                            {
                                this.BoostArray.Push(Real2(x, y));
                            }
                        }
                    } // End BoostArray
                }
            }
            if(Zero.Keyboard.KeyIsPressed(Keys.D))
            {
                if(this.I_NumBoosts > 0)
                {
                    this.GameSession.DispatchEvent(Events.DecrementBoosts, new Event());
                    
                    this.PauseReason = Enum_PauseReason.BoostUsed;
                    this.BoostType = Enum_BlockType.Block_Two_Static;
                    
                    this.BoostArray = new Array[Real2]();
                
                    // Create array of blocks to destroy
                    for(var y = 0; y < this.I_LevelHeight; ++y)
                    {
                        for(var x = 0; x < this.I_LevelWidth; ++x)
                        {
                            if(this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == this.BoostType)
                            {
                                this.BoostArray.Push(Real2(x, y));
                            }
                        }
                    }
                    
                } // End If
            }
            
        }
        else // Game is Paused (Due to destroying blocks or game is over)
        {
            if(this.PauseReason == Enum_PauseReason.GameBegin)
            {
                var randMusic = this.Rand.DieRoll(4);
                if(randMusic == 1)
                {
                    this.GameSession.DispatchEvent(Events.LoadTheme_One, new Event());
                }
                else if(randMusic == 2)
                {
                    this.GameSession.DispatchEvent(Events.LoadTheme_Two, new Event());
                }
                else if(randMusic == 3)
                {
                    this.GameSession.DispatchEvent(Events.LoadTheme_Three, new Event());
                }
                else
                {
                    this.GameSession.DispatchEvent(Events.LoadTheme_Four, new Event());
                }
                
                var incrementBoosts = new IncrementBoosts();
                
                for(var i = 0; i < this.I_NumBoosts; ++i)
                {
                    this.GameSession.DispatchEvent(Events.IncrementBoosts, new Event());
                }
                
                this.PauseReason = Enum_PauseReason.None;
            }
            // Score a line
            else if(this.PauseReason == Enum_PauseReason.ScoreLine)
            {
                if(this.R_Timer >= 0.125)
                {
                    if(this.I_PathfindingCheck < (this.ScoreArray.Count))
                    {
                        var blockX = this.ScoreArray.Get(this.I_PathfindingCheck).X;
                        var blockY = this.ScoreArray.Get(this.I_PathfindingCheck).Y;
                        
                        // Play the sound effect attached to the block
                        this.BoardGrid.Get(blockY as Integer).Get(blockX as Integer).SoundEmitter.Play();
                        
                        this.ConvertBlocks(blockX as Integer, blockY as Integer);
                        
                        this.I_PathfindingCheck += 1;
                        this.R_Timer = 0;
                    }
                    else
                    {
                        // Clear the blocks from the field
                        // For the length of the scoreLine array, find each individual block and delete it from the BoardGrid
                        for(var i = 0; i < this.ScoreArray.Count; ++i)
                        {
                            this.BoardGrid.Get(this.ScoreArray.Get(i).Y as Integer).Get(this.ScoreArray.Get(i).X as Integer).Z_BlockLogic.BlockType = Enum_BlockType.None;
                        }
                        
                        this.PathfindingArray = new Array[Real2]();
                        this.ScoreArray = new Array[Real2]();
                        
                        this.I_PathfindingCheck = 0;
                        
                        this.ConsolidateBlocks();
                        
                        if(this.I_Score == 28 && this.ScoreArray.Count == 0)
                        {
                            this.PauseReason = Enum_PauseReason.WinGame;
                        }
                        else
                        {
                            this.PauseReason = Enum_PauseReason.None;
                        }
                    }
                }
            }
            // Boost was used
            else if(this.PauseReason == Enum_PauseReason.BoostUsed)
            {
                this.B_AllowedToCheck = true;
                
                if(this.R_Timer >= 0.05)
                {
                    if(this.I_PathfindingCheck < this.BoostArray.Count)
                    {
                        this.BoardGrid.Get(this.BoostArray.Get(this.I_PathfindingCheck).Y as Integer).Get(this.BoostArray.Get(this.I_PathfindingCheck).X as Integer).Z_BlockLogic.BlockType = Enum_BlockType.None;
                        
                        // Place explosion here
                        this.BoardGrid.Get(this.BoostArray.Get(this.I_PathfindingCheck).Y as Integer).Get(this.BoostArray.Get(this.I_PathfindingCheck).X as Integer).FindChildByName("FireParticleEffect").SphericalParticleEmitter.ResetCount();
                        this.BoardGrid.Get(this.BoostArray.Get(this.I_PathfindingCheck).Y as Integer).Get(this.BoostArray.Get(this.I_PathfindingCheck).X as Integer).FindChildByName("FireParticleEffect").SphericalParticleEmitter.Active = true;
                        
                        this.I_PathfindingCheck += 1;
                        this.R_Timer = 0;
                    }
                    else
                    {
                        if(this.R_Timer >= 1.0)
                        {
                            this.I_PathfindingCheck = 0;
                        
                            this.ConsolidateBlocks();
                            
                            this.I_NumBoosts -= 1;
                            
                            this.PauseReason = Enum_PauseReason.None;
                            this.R_Timer = 0;
                        }
                    }
                }
            } // End B_BoostUsed
            else if(this.PauseReason == Enum_PauseReason.WinGame)
            {
                if(this.R_Timer >= 3.0)
                {
                    while(this.GameSession.FindSpaceByName("LevelSpace") != null)
                    {
                        this.GameSession.FindSpaceByName("LevelSpace").Destroy();
                    }
                    
                    while(this.GameSession.FindSpaceByName("ThemeSpace") != null)
                    {
                        this.GameSession.FindSpaceByName("ThemeSpace").Destroy();
                    }
                    
                    while(this.GameSession.FindSpaceByName("HudSpace") != null)
                    {
                        this.GameSession.FindSpaceByName("HudSpace").Destroy();
                    }
                    
                    this.GameSession.CreateNamedSpace("Main", Archetype.Find("Space"));
                    this.GameSession.FindSpaceByName("Main").LoadLevel(Level.Find("Tutorial_3"));
                }
            } // End WinGame
            else if(this.PauseReason == Enum_PauseReason.GameOver)
            {
                if( this.I_GO_X >= (this.I_LevelWidth - 1) &&
                    this.I_GO_Y >= (this.I_LevelHeight - 1) )
                    {
                        // Purposefully breaking out to avoid a crash for now
                        this.ConvertBlocks(this.I_GO_X, this.I_GO_Y);
                        
                        if(this.R_Timer >= 3.0)
                        {
                            while(this.GameSession.FindSpaceByName("LevelSpace") != null)
                            {
                                this.GameSession.FindSpaceByName("LevelSpace").Destroy();
                            }
                            
                            while(this.GameSession.FindSpaceByName("ThemeSpace") != null)
                            {
                                this.GameSession.FindSpaceByName("ThemeSpace").Destroy();
                            }
                            
                            while(this.GameSession.FindSpaceByName("HudSpace") != null)
                            {
                                this.GameSession.FindSpaceByName("HudSpace").Destroy();
                            }
                            
                            this.GameSession.CreateNamedSpace("Main", Archetype.Find("Space"));
                            this.GameSession.FindSpaceByName("Main").LoadLevel(Level.Find("Tutorial_2"));
                        }
                        
                    }
                else if(this.R_Timer > 0.01)
                {
                    this.ConvertBlocks(this.I_GO_X, this.I_GO_Y);
                    
                    // We move horizontally to replace each block with a Game Over block.
                    ++this.I_GO_X;
                    
                    // When we reach the end of a layer, we increment a layer and start over, horizontally
                    if(this.I_GO_X >= this.I_LevelWidth)
                    {
                        if(this.I_GO_Y < this.I_LevelHeight)
                        {
                            ++this.I_GO_Y;
                            this.I_GO_X = 0;
                        }
                    }
                    // Reset the timer
                    this.R_Timer = 0;
                }
            } // End B_GameOver
        }
    }
//
}