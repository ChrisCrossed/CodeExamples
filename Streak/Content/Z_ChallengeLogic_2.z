class Z_ChallengeLogic_2 : ZilchComponent
{
    sends IncrementScore : Event;
    sends IncrementBoosts : Event;
    sends DecrementBoosts : Event;
    sends LoadRandomThemeNow : Event;
    sends OnGameRequestQuit : GameEvent;
    sends GameTimeLength : Event;
    sends CheckTimer : Event;
    sends HUDTimer_GameOver : Event;
    
    // Set the level's height and width
    [Property]
    var I_LevelWidth:Integer = 16;
    [Property]
    var I_LevelHeight:Integer = 10;
    
    [Property]
    var R_BLOCK_TIMER_SECONDS:Real = 0.75;
    var B_IsUnlimitedMode:Boolean = false;
    
    var R_Timer:Real = 0;
    var R_ButtonTimer:Real = 0;
    
    var Rand:Random = new Random();
    
    var ArchBlock:Archetype = Archetype.Find("Block");
    
    var BoardGrid:Array[Array[Cog]] = new Array[Array[Cog]]();
    var PathfindingArray:Array[Real2] = new Array[Real2]();
    var ScoreArray:Array[Real2] = new Array[Real2]();
    var B_FoundSolution:Boolean = false;
    
    var B_AllowedToCheck:Boolean = true;
    var B_AllowedToMoveBlocks:Boolean = true;
    
    var I_RecCheck:Integer = 0;
    
    var I_Score:Integer = 0;
    var I_SpeedUpBasedOnScore:Integer = 0;
    
    [Property]
    var I_NumBoosts:Integer = 3;
    var I_TimeLengthMinutes:Integer = 0;
    var ScoreToAddBoost:Integer = 250;
    
    var ScoreCheck:Integer = 0;
    var Score_Red:Integer = 0;
    var Score_Blue:Integer = 0;
    
    var PauseReason:Enum_PauseReason = Enum_PauseReason.GameBegin;
    
    var B_BoostUsed:Boolean = false;
    var BoostType:Enum_BlockType = Enum_BlockType.None;
    var BoostArray:Array[Real2] = new Array[Real2]();
    
    var NextBlockArray:Array[Enum_BlockType] = new Array[Enum_BlockType]();
    var SoundArray:Array[Cog] = new Array[Cog](16);
    
    // Game Over block X/Y
    var I_GO_X:Integer = 1;
    var I_GO_Y:Integer = 0;
    
    var I_PathfindingCheck:Integer = 0;
    
    var ScoreboardSpace : Space = null;
    var ScoreboardLevel : Level = null;
    
    var GameModeType : Enum_ScoreboardType = Enum_ScoreboardType.Normal_5;
    var DataCog:Cog = null;
    var StarArray:Array[Boolean] = new Array[Boolean](2);
    var I_NumTurns:Integer = 0;
    var I_ParTurns:Integer = 15;
    
    var Arrow_5_2:Cog = null;
    var Arrow_5_3:Cog = null;
    var Arrow_5_4:Cog = null;
    var Arrow_6_1:Cog = null;
    var Arrow_6_2:Cog = null;
    var Arrow_6_3:Cog = null;
    var Arrow_6_4:Cog = null;
    var Arrow_6_5:Cog = null;
    var Arrow_7_1:Cog = null;
    var Arrow_7_2:Cog = null;
    var Arrow_7_3:Cog = null;
    var Arrow_7_4:Cog = null;
    var Arrow_7_5:Cog = null;
    var Arrow_8_1:Cog = null;
    var Arrow_8_2:Cog = null;
    var Arrow_8_3:Cog = null;
    var Arrow_8_4:Cog = null;
    var Arrow_8_5:Cog = null;
    var Arrow_9_2:Cog = null;
    var Arrow_9_3:Cog = null;
    var Arrow_9_4:Cog = null;
    
    
    function Initialize(init : CogInitializer)
    {
        // this.LoadInitialization(this.I_LevelWidth, this.I_LevelHeight, 1.5, this.I_NumBoosts, 0, -1);
    }
    
    /*******************************************************************************/
    /*
        Description:
            Initializes the level with preset details (for Easy, Medium & Hard mode)
        
        Parameters:
            - levelWidth (Integer): Number of board spaces within the level (Horizontal)
            - levelHeight (Integer): Number of board spaces within the level (Vertical)
            - blockDropSpeed (Real): Time (in seconds) to wait until a block drops
            - startingBoosts (Integer): Number of Boosts the player begins with
            - moveCameraX (Real): Amount of space to move the camera horizontally to fit the game
            - timeLengthMinutes (Integer): Time length in minutes to make the game play
            
        Return:
            - None
    */
    /*******************************************************************************/
    function LoadInitialization(levelWidth : Integer, levelHeight : Integer, blockDropSpeed : Real, startingBoosts : Integer, moveCameraX : Real, timeLengthMinutes : Integer)
    {
        this.I_LevelWidth = levelWidth;
        this.I_LevelHeight = levelHeight;
        this.R_BLOCK_TIMER_SECONDS = blockDropSpeed;
        this.I_NumBoosts = startingBoosts;
        this.ScoreToAddBoost = 250;
        
        this.DataCog = Zero.ObjectStore.RestoreOrArchetype("SaveFile", "SavedData", this.Space);
        
        this.ScoreboardSpace = this.GameSession.CreateNamedSpace("LevelSpace", Archetype.Find("Space"));
        this.ScoreboardLevel = Level.Find("Game_Scoreboard");
        this.ScoreboardSpace = this.GameSession.FindSpaceByName("LevelSpace");
        
        this.DetermineGamemodeType(levelWidth, levelHeight, timeLengthMinutes);
        
        this.LoadStarArray();
        
        if(timeLengthMinutes > 0)
        {
            this.B_IsUnlimitedMode = false;
        }
        else
        {
            this.B_IsUnlimitedMode = true;
        }
        
        if(!this.B_IsUnlimitedMode)
        {
            var dispatchTimeLength = new SendsTimeLength(); ///
            dispatchTimeLength.TimeLength = timeLengthMinutes * 60;
            Console.WriteLine("Time Sent: `dispatchTimeLength.TimeLength`");
            this.GameSession.DispatchEvent(Events.GameTimeLength, dispatchTimeLength);
        }
        
        var newCamPos = this.Space.FindObjectByName("Camera").Transform.Translation;
        newCamPos.X += moveCameraX;
        this.Space.FindObjectByName("Camera").Transform.Translation = newCamPos;
        
        this.I_LevelWidth += 2;
        
        this.CreateWalls();
        
        // Generate the board (Y Axis)
        for(var y = 0; y < this.I_LevelHeight; ++y)
        {
            this.BoardGrid.Add(new Array[Cog]());
        }
        
        // Generate the board (X Axis)
        for(var y = 0; y < this.I_LevelHeight; ++y)
        {
            for(var x = 0; x < this.I_LevelWidth; ++x)
            {
                // Get the Y first, then set the X
                var archBlock = this.Space.CreateAtPosition(Archetype.Find("Block"), Real3(x + 0.5, y + 0.5, 0));
                archBlock.Z_BlockLogic.BlockType = Enum_BlockType.None;
                this.BoardGrid.Get(y).Push(archBlock);
            }
        }
        
        this.Arrow_5_2 = this.Space.FindObjectByName("Arrow_5,2");
        this.Arrow_5_3 = this.Space.FindObjectByName("Arrow_5,3");
        this.Arrow_5_4 = this.Space.FindObjectByName("Arrow_5,4");
        this.Arrow_6_1 = this.Space.FindObjectByName("Arrow_6,1");
        this.Arrow_6_2 = this.Space.FindObjectByName("Arrow_6,2");
        this.Arrow_6_3 = this.Space.FindObjectByName("Arrow_6,3");
        this.Arrow_6_4 = this.Space.FindObjectByName("Arrow_6,4");
        this.Arrow_6_5 = this.Space.FindObjectByName("Arrow_6,5");
        this.Arrow_7_1 = this.Space.FindObjectByName("Arrow_7,1");
        this.Arrow_7_2 = this.Space.FindObjectByName("Arrow_7,2");
        this.Arrow_7_3 = this.Space.FindObjectByName("Arrow_7,3");
        this.Arrow_7_4 = this.Space.FindObjectByName("Arrow_7,4");
        this.Arrow_7_5 = this.Space.FindObjectByName("Arrow_7,5");
        this.Arrow_8_1 = this.Space.FindObjectByName("Arrow_8,1");
        this.Arrow_8_2 = this.Space.FindObjectByName("Arrow_8,2");
        this.Arrow_8_3 = this.Space.FindObjectByName("Arrow_8,3");
        this.Arrow_8_4 = this.Space.FindObjectByName("Arrow_8,4");
        this.Arrow_8_5 = this.Space.FindObjectByName("Arrow_8,5");
        this.Arrow_9_2 = this.Space.FindObjectByName("Arrow_9,2");
        this.Arrow_9_3 = this.Space.FindObjectByName("Arrow_9,3");
        this.Arrow_9_4 = this.Space.FindObjectByName("Arrow_9,4");
        
        
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        Zero.Connect(this.GameSession, Events.GameRequestQuit, this.OnGameRequestQuit);
        
        Zero.Connect(this.GameSession, Events.TimerGameOver, this.OnTimerGameOver);
    }
//
    function ChallengeWinCondition()
    {
        // Reset score value check
        this.Score_Red = 0;
        this.Score_Blue = 0;
        
        this.ChangeMarkerColor(this.Arrow_5_2, this.BoardGrid.Get(2).Get(5).Z_BlockLogic.BlockType);
        this.ChangeMarkerColor(this.Arrow_5_3, this.BoardGrid.Get(3).Get(5).Z_BlockLogic.BlockType);
        this.ChangeMarkerColor(this.Arrow_5_4, this.BoardGrid.Get(4).Get(5).Z_BlockLogic.BlockType);
        
        this.ChangeMarkerColor(this.Arrow_6_1, this.BoardGrid.Get(1).Get(6).Z_BlockLogic.BlockType);
        this.ChangeMarkerColor(this.Arrow_6_2, this.BoardGrid.Get(2).Get(6).Z_BlockLogic.BlockType);
        this.ChangeMarkerColor(this.Arrow_6_3, this.BoardGrid.Get(3).Get(6).Z_BlockLogic.BlockType);
        this.ChangeMarkerColor(this.Arrow_6_4, this.BoardGrid.Get(4).Get(6).Z_BlockLogic.BlockType);
        this.ChangeMarkerColor(this.Arrow_6_5, this.BoardGrid.Get(5).Get(6).Z_BlockLogic.BlockType);
        
        this.ChangeMarkerColor(this.Arrow_7_1, this.BoardGrid.Get(1).Get(7).Z_BlockLogic.BlockType);
        this.ChangeMarkerColor(this.Arrow_7_2, this.BoardGrid.Get(2).Get(7).Z_BlockLogic.BlockType);
        this.ChangeMarkerColor(this.Arrow_7_3, this.BoardGrid.Get(3).Get(7).Z_BlockLogic.BlockType);
        this.ChangeMarkerColor(this.Arrow_7_4, this.BoardGrid.Get(4).Get(7).Z_BlockLogic.BlockType);
        this.ChangeMarkerColor(this.Arrow_7_5, this.BoardGrid.Get(5).Get(7).Z_BlockLogic.BlockType);
        
        this.ChangeMarkerColor(this.Arrow_8_1, this.BoardGrid.Get(1).Get(8).Z_BlockLogic.BlockType);
        this.ChangeMarkerColor(this.Arrow_8_2, this.BoardGrid.Get(2).Get(8).Z_BlockLogic.BlockType);
        this.ChangeMarkerColor(this.Arrow_8_3, this.BoardGrid.Get(3).Get(8).Z_BlockLogic.BlockType);
        this.ChangeMarkerColor(this.Arrow_8_4, this.BoardGrid.Get(4).Get(8).Z_BlockLogic.BlockType);
        this.ChangeMarkerColor(this.Arrow_8_5, this.BoardGrid.Get(5).Get(8).Z_BlockLogic.BlockType);
        
        this.ChangeMarkerColor(this.Arrow_9_2, this.BoardGrid.Get(2).Get(9).Z_BlockLogic.BlockType);
        this.ChangeMarkerColor(this.Arrow_9_3, this.BoardGrid.Get(3).Get(9).Z_BlockLogic.BlockType);
        this.ChangeMarkerColor(this.Arrow_9_4, this.BoardGrid.Get(4).Get(9).Z_BlockLogic.BlockType);
        
        // Lose Condition
        if(this.Score_Red > 0 && this.Score_Blue > 0)
        {
            this.PauseReason = Enum_PauseReason.GameOver;
        }
        
        // Win Condition
        if(this.Score_Red >= 21 || this.Score_Blue >= 21)
        {
            var backStar = this.Space.FindObjectByName("Star_Circle_Complete").FindChildByName("Star_Circle_Background");
            this.LightStar(backStar);
            
            this.StarArray.Set(0, true);
            
            if(this.I_NumTurns <= this.I_ParTurns)
            {
                this.StarArray.Set(1, true);
                
                backStar = this.Space.FindObjectByName("Star_Circle_NumTries").FindChildByName("Star_Circle_Background");
                this.LightStar(backStar);
            }
            
            this.SaveStarArray();
            
            this.PauseReason = Enum_PauseReason.WinGame;
        }
    }
//
    function LightStar(starToLight : Cog)
    {
        var seq = Action.Sequence(this.Owner.Actions);
        var group = Action.Group(seq);
        
        var goldColor = Real4(0.78, 0.625, 0, 1);
        
        Action.Property(seq, @starToLight.Sprite.Color, goldColor, 0.3, Ease.QuadOut);
    }
//
    function ChangeMarkerColor(arrow : Cog, blockType : Enum_BlockType)
    {
        if(blockType == Enum_BlockType.Block_One_Static) // Red
        {
            arrow.Sprite.Color = Real4(1,0,0,1);
            this.Score_Red += 1;
            arrow.Sprite.SpriteSource = SpriteSource.Find("CheckBox");
        }
        else if(blockType == Enum_BlockType.Block_Two_Static) // Blue
        {
            arrow.Sprite.Color = Real4(0,0,1,1);
            this.Score_Blue += 1;
            arrow.Sprite.SpriteSource = SpriteSource.Find("CheckBox");
        }
        else
        {
            arrow.Sprite.SpriteSource = SpriteSource.Find("XMark");
        }
    }
//
    function OnGameRequestQuit(gameEvent : GameEvent)
    {
        Console.WriteLine("ESC Pressed");
        // this.GameSession.FindSpaceByName("Main").LoadLevel(Level.Find("Menu_MainMenu"));
        // this.GameSession.FindSpaceByName("HudSpace").Destroy();
        // this.Space.Destroy();
        gameEvent.Handled = true;
    }
//
    function LoadStarArray()
    {
        this.StarArray.Set(0, this.DataCog.Z_DataSaver.Challenge_Two_Complete);
        Console.WriteLine(this.StarArray.Get(0));
        if(this.StarArray.Get(0))
        {
            this.Space.FindObjectByName("Star_Circle_Complete").Sprite.SpriteSource = SpriteSource.Find("StarOn");
        }
        
        this.StarArray.Set(1, this.DataCog.Z_DataSaver.Challenge_Two_NumTurns);
        if(this.StarArray.Get(1))
        {
            this.Space.FindObjectByName("Star_Circle_NumTries").Sprite.SpriteSource = SpriteSource.Find("StarOn");
        }
    }
//
    function SaveStarArray()
    {
        this.DataCog.Z_DataSaver.Challenge_Two_Complete = this.StarArray.Get(0);
        this.DataCog.Z_DataSaver.Challenge_Two_NumTurns = this.StarArray.Get(1);
        
        Zero.ObjectStore.Store("SaveFile", this.DataCog);
    }
//
    function CreateWalls()
    {
        // Create bottom wall
        for(var i = 1; i < this.I_LevelWidth - 1; ++i)
        {
            this.Space.CreateAtPosition(Archetype.Find("Block_Ground"), Real3(i + 0.5, -0.5, 0));
        }
        
        // Create walls (Starting equal height of the ground
        for(var j = -1; j < this.I_LevelHeight; ++j)
        {
            // Creates left wall
            this.Space.CreateAtPosition(Archetype.Find("Block_Wall"), Real3(+0.5, j + 0.5, -3));
            
            // Creates right wall
            this.Space.CreateAtPosition(Archetype.Find("Block_Wall"), Real3(this.I_LevelWidth - 0.5, j + 0.5, -3));
        }
    }
    
//
    function Create2x2()
    {
        if(this.NextBlockArray.Count < 8)
        {
            for(var i = this.NextBlockArray.Count; i < 8; ++i)
            {
                if(this.Rand.CoinFlip())
                {
                    this.NextBlockArray.Push(Enum_BlockType.Block_One_Active);
                }
                else
                {
                    this.NextBlockArray.Push(Enum_BlockType.Block_Two_Active);
                }
            }
        }
        
        // First, check to see any of the dead center top pieces are empty
        if( this.BoardGrid.Get(this.I_LevelHeight - 1).Get((this.I_LevelWidth / 2) - 1).Z_BlockLogic.BlockType == Enum_BlockType.None   || 
            this.BoardGrid.Get(this.I_LevelHeight - 1).Get(this.I_LevelWidth / 2).Z_BlockLogic.BlockType == Enum_BlockType.None         || 
            this.BoardGrid.Get(this.I_LevelHeight - 2).Get((this.I_LevelWidth / 2) - 1).Z_BlockLogic.BlockType == Enum_BlockType.None   || 
            this.BoardGrid.Get(this.I_LevelHeight - 2).Get(this.I_LevelWidth / 2).Z_BlockLogic.BlockType == Enum_BlockType.None          )
            {
                // If they are empty, randomly set the four positions to be an active piece
                for(var i = 0; i < this.NextBlockArray.Count; ++i)
                {
                    if(i < 4)
                    {
                        // Get an arbitrary block
                        var testBlock = this.BoardGrid.Get(0).Get(0);
                        
                        if(i == 0)
                        {
                            testBlock = this.BoardGrid.Get(this.I_LevelHeight - 2).Get((this.I_LevelWidth / 2) - 1);
                        }
                        else if(i == 1)
                        {
                            testBlock = this.BoardGrid.Get(this.I_LevelHeight - 2).Get(this.I_LevelWidth / 2);
                        }
                        else if(i == 2)
                        {
                            testBlock = this.BoardGrid.Get(this.I_LevelHeight - 1).Get((this.I_LevelWidth / 2) - 1);
                        }
                        else if(i == 3)
                        {
                            testBlock = this.BoardGrid.Get(this.I_LevelHeight - 1).Get(this.I_LevelWidth / 2);
                        }
                        
                        testBlock.Z_BlockLogic.BlockType = this.NextBlockArray.Get(i);
                    }
                    else
                    {
                        if(i == 4)
                        {
                            if(this.NextBlockArray.Get(i) == Enum_BlockType.Block_One_Active)
                            {
                                this.GameSession.DispatchEvent(Events.HUDBlock_BottomLeft_BlockOne, new Event());
                            }
                            else
                            {
                                this.GameSession.DispatchEvent(Events.HUDBlock_BottomLeft_BlockTwo, new Event());
                            }
                        }
                        else if(i == 5)
                        {
                            if(this.NextBlockArray.Get(i) == Enum_BlockType.Block_One_Active)
                            {
                                this.GameSession.DispatchEvent(Events.HUDBlock_BottomRight_BlockOne, new Event());
                            }
                            else
                            {
                                this.GameSession.DispatchEvent(Events.HUDBlock_BottomRight_BlockTwo, new Event());
                            }
                        }
                        else if(i == 6)
                        {
                            if(this.NextBlockArray.Get(i) == Enum_BlockType.Block_One_Active)
                            {
                                this.GameSession.DispatchEvent(Events.HUDBlock_TopLeft_BlockOne, new Event());
                            }
                            else
                            {
                                this.GameSession.DispatchEvent(Events.HUDBlock_TopLeft_BlockTwo, new Event());
                            }
                        }
                        else if(i == 7)
                        {
                            if(this.NextBlockArray.Get(i) == Enum_BlockType.Block_One_Active)
                            {
                                this.GameSession.DispatchEvent(Events.HUDBlock_TopRight_BlockOne, new Event());
                            }
                            else
                            {
                                this.GameSession.DispatchEvent(Events.HUDBlock_TopRight_BlockTwo, new Event());
                            }
                        }
                    }
                } // End ForLoop
            } // End If
        
            
        // If not empty, re-populate the top four with random static blocks
        else
        {
            // If they are empty, randomly set the four positions to be an active piece
            for(var i = 0; i <= 4; ++i)
            {
                // Get an arbitrary block
                var testBlock = this.BoardGrid.Get(this.I_LevelHeight - 1).Get((this.I_LevelWidth / 2) - 1);
                var runTest = false;
                
                if(i == 1 && this.BoardGrid.Get(this.I_LevelHeight - 1).Get((this.I_LevelWidth / 2) - 1).Z_BlockLogic.BlockType == Enum_BlockType.None)
                {
                    runTest = true;
                }
                else if(i == 2 && this.BoardGrid.Get(this.I_LevelHeight - 1).Get(this.I_LevelWidth / 2).Z_BlockLogic.BlockType == Enum_BlockType.None)
                {
                    testBlock = this.BoardGrid.Get(this.I_LevelHeight - 1).Get(this.I_LevelWidth / 2);
                    runTest = true;
                }
                else if(i == 3 && this.BoardGrid.Get(this.I_LevelHeight - 2).Get((this.I_LevelWidth / 2) - 1).Z_BlockLogic.BlockType == Enum_BlockType.None)
                {
                    testBlock = this.BoardGrid.Get(this.I_LevelHeight - 2).Get((this.I_LevelWidth / 2) - 1);
                    runTest = true;
                }
                else if(i == 4 && this.BoardGrid.Get(this.I_LevelHeight - 2).Get(this.I_LevelWidth / 2).Z_BlockLogic.BlockType == Enum_BlockType.None)
                {
                    testBlock = this.BoardGrid.Get(this.I_LevelHeight - 2).Get(this.I_LevelWidth / 2);
                    runTest = true;
                }
                
                if(runTest)
                {
                    if(this.Rand.CoinFlip())
                    {
                        testBlock.Z_BlockLogic.BlockType = Enum_BlockType.Block_One_Static;
                    }
                    else
                    {
                        testBlock.Z_BlockLogic.BlockType = Enum_BlockType.Block_Two_Static;
                    }
                } // End 'If'-tests
            } // End ForLoop
            
            // Run EndGame
            this.PauseReason = Enum_PauseReason.GameOver;
            this.GameSession.DispatchEvent(Events.HUDTimer_GameOver, new Event());
        }
        
        // Clearing the first four positions of the array
        for(var j = 0; j < 4; ++j)
        {
            this.NextBlockArray.RemoveAt(0);
        }
    }

//
    function AllBlocksStatic()
    {
        for(var x = 0; x < this.I_LevelWidth; ++x)
        {
            for(var y = 0; y < this.I_LevelHeight; ++y)
            {
                if(x == 0 || x == this.I_LevelWidth - 1)
                {
                    this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType = Enum_BlockType.None;
                }
                
                if(this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == Enum_BlockType.Block_One_Active)
                {
                    this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType = Enum_BlockType.Block_One_Static;
                }
                else if(this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == Enum_BlockType.Block_Two_Active)
                {
                    this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType = Enum_BlockType.Block_Two_Static;
                }
            }
        }
        
        this.ConsolidateBlocks();
        this.DetermineScoreLine();
        this.B_AllowedToCheck = true;
        this.Create2x2();
        
        var blockDrop = this.Space.Create(Archetype.Find("SFX_BlockDrop"));
        blockDrop.SoundEmitter.Play();
    }
//
    function GenerateActiveBlocksArray():Array[Real2]
    {
        // Find each coordinate of the Active blocks and put the coordinates into an array
        var activeArray:Array[Real2] = new Array[Real2]();
        for(var y = 0; y < this.I_LevelHeight; ++y)
        {
            for(var x = 0; x < this.I_LevelWidth; ++x)
            {
                if( this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == Enum_BlockType.Block_One_Active ||
                    this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == Enum_BlockType.Block_Two_Active  )
                    {
                        var currentPos:Real2 = Real2(x, y);
                        activeArray.Push(currentPos);
                    }
            }
        }
        
        return activeArray;
    }
//
    function MoveBlocks(moveDir : Enum_MoveDirection)
    {
        var activeArray = this.GenerateActiveBlocksArray();
        
        var canMoveLeft:Boolean = false;
        var canMoveRight:Boolean = false;
        
        // Determine if blocks to the right of our active array exist or not
        if( (activeArray.Get(0).X as Integer - 1) >= 0 &&
            (activeArray.Get(2).X as Integer - 1) >= 0 &&
            this.BoardGrid.Get(activeArray.Get(0).Y as Integer).Get(activeArray.Get(0).X as Integer - 1).Z_BlockLogic.BlockType == Enum_BlockType.None &&
            this.BoardGrid.Get(activeArray.Get(2).Y as Integer).Get(activeArray.Get(2).X as Integer - 1).Z_BlockLogic.BlockType == Enum_BlockType.None  )
            {
                canMoveLeft = true;
            }
            
        // Determine if blocks to the right of our active array exist or not
        if( (activeArray.Get(1).X as Integer + 1) < this.I_LevelWidth &&
            (activeArray.Get(3).X as Integer + 1) < this.I_LevelWidth &&
            this.BoardGrid.Get(activeArray.Get(1).Y as Integer).Get(activeArray.Get(1).X as Integer + 1).Z_BlockLogic.BlockType == Enum_BlockType.None &&
            this.BoardGrid.Get(activeArray.Get(3).Y as Integer).Get(activeArray.Get(3).X as Integer + 1).Z_BlockLogic.BlockType == Enum_BlockType.None   )
            {
                canMoveRight = true;
            }
        
        // Depending on whether we are going left/down or right, we cycle through and shift the blocks in order (or reverse order) depending on the array.
        for(var i = 0; i < activeArray.Count; ++i)
        {
            // Determine what direction we need to move
            if(moveDir == Enum_MoveDirection.Down)
            {
                // Check to see if the spot below exists
                if( activeArray.Get(i).Y > 0 &&
                    this.BoardGrid.Get(activeArray.Get(i).Y as Integer - 1).Get(activeArray.Get(i).X as Integer).Z_BlockLogic.BlockType == Enum_BlockType.None)
                {
                    var arrayPos = activeArray.Get(i);
                    var currentPos = this.BoardGrid.Get(arrayPos.Y as Integer).Get(arrayPos.X as Integer);
                    this.BoardGrid.Get(arrayPos.Y as Integer - 1).Get(arrayPos.X as Integer).Z_BlockLogic.BlockType = currentPos.Z_BlockLogic.BlockType;
                    this.BoardGrid.Get(arrayPos.Y as Integer).Get(arrayPos.X as Integer).Z_BlockLogic.BlockType = Enum_BlockType.None;
                }
                else // We turn all bricks into Static
                {
                    this.AllBlocksStatic();
                    this.R_Timer = 0;
                    break;
                }
                this.R_Timer = 0;
            }
            else if(moveDir == Enum_MoveDirection.Left && canMoveLeft)
            {
                if( activeArray.Get(i).X as Integer > 0 &&
                this.BoardGrid.Get(activeArray.Get(i).Y as Integer).Get(activeArray.Get(i).X as Integer - 1).Z_BlockLogic.BlockType == Enum_BlockType.None)
                {
                    var arrayPos = activeArray.Get(i);
                    var currentPos = this.BoardGrid.Get(arrayPos.Y as Integer).Get(arrayPos.X as Integer);
                    this.BoardGrid.Get(arrayPos.Y as Integer).Get(arrayPos.X as Integer - 1).Z_BlockLogic.BlockType = currentPos.Z_BlockLogic.BlockType;
                    this.BoardGrid.Get(arrayPos.Y as Integer).Get(arrayPos.X as Integer).Z_BlockLogic.BlockType = Enum_BlockType.None;
                }
            }
            else if(moveDir == Enum_MoveDirection.Right && canMoveRight)
            {
                // recording the REVERSE ORDER of the array of blocks to move
                var j = (activeArray.Count - 1) - i;
                if( (activeArray.Get(j).X < (this.I_LevelWidth - 1) ) &&
                    this.BoardGrid.Get(activeArray.Get(j).Y as Integer).Get(activeArray.Get(j).X as Integer + 1).Z_BlockLogic.BlockType == Enum_BlockType.None)
                    {
                        var arrayPos = activeArray.Get(j);
                        var currentPos = this.BoardGrid.Get(arrayPos.Y as Integer).Get(arrayPos.X as Integer);
                        this.BoardGrid.Get(activeArray.Get(j).Y as Integer).Get(activeArray.Get(j).X as Integer + 1).Z_BlockLogic.BlockType = currentPos.Z_BlockLogic.BlockType;
                        this.BoardGrid.Get(activeArray.Get(j).Y as Integer).Get(activeArray.Get(j).X as Integer).Z_BlockLogic.BlockType = Enum_BlockType.None;
                    }
            }
            else if(!canMoveLeft && !canMoveRight)// We turn all bricks into Static
            {
                this.AllBlocksStatic();
                break;
            }
        }
    } // End MoveBlocks()
//
    function ConsolidateBlocks()
    {
        ++this.I_NumTurns;
        
        this.GameSession.DispatchEvent("IncrementScore", new Event());
        
        // We begin with X instead of Y so that we loop upward, not horizontally. (Imagine that we are pulling each column down, moving left to right)
        for(var x = 0; x < this.I_LevelWidth; ++x)
        {
            // Start on the 2nd layer since we aren't moving down the bottom layer
            for(var y = 1; y < this.I_LevelHeight; ++y)
            {
                // This function was called when we already know all blocks are static, so we can move blocks down.
                if( this.BoardGrid.Get(y - 1).Get(x).Z_BlockLogic.BlockType == Enum_BlockType.None  && 
                    (   this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == Enum_BlockType.Block_One_Static ||
                        this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == Enum_BlockType.Block_Two_Static) )
                    {
                        this.BoardGrid.Get(y - 1).Get(x).Z_BlockLogic.BlockType = this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType;
                        this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType = Enum_BlockType.None;
                        
                        // Run the check again each time we find a block we need to move
                        // this.ConsolidateBlocks();
                        y = 0;
                    } // End If
            } // End For(x) loop
        } // End For(y) loop
        this.B_AllowedToCheck = true;
        
        // Used as a keyboard button check to ensure more blocks don't zip around once new blocks are created
        this.B_AllowedToMoveBlocks = false;
        
        var blockDrop = this.Space.Create(Archetype.Find("SFX_BlockDrop"));
        blockDrop.SoundEmitter.Play();
    }
//
    function RotateBlocks(rotateCounterClock : Boolean)
    {
        // Store the current active block positions
        var activeArray = this.GenerateActiveBlocksArray();
        var manipulateArray:Array[Enum_BlockType] = new Array[Enum_BlockType]();
        for(var i = 0; i < 4; ++i)
        {
            manipulateArray.Push(this.BoardGrid.Get(activeArray.Get(i).Y as Integer).Get(activeArray.Get(i).X as Integer).Z_BlockLogic.BlockType);
        }
        
        // Rotate Counter-Clockwise
        if(rotateCounterClock)
        {
            // Bottom Left receives Top Left
            this.BoardGrid.Get(activeArray.Get(0).Y as Integer).Get(activeArray.Get(0).X as Integer).Z_BlockLogic.BlockType = manipulateArray.Get(2);
            
            // Top Left receives Top Right
            this.BoardGrid.Get(activeArray.Get(2).Y as Integer).Get(activeArray.Get(2).X as Integer).Z_BlockLogic.BlockType = manipulateArray.Get(3);
            
            // Top Right receives Bottom Right
            this.BoardGrid.Get(activeArray.Get(3).Y as Integer).Get(activeArray.Get(3).X as Integer).Z_BlockLogic.BlockType = manipulateArray.Get(1);
            
            // Bottom Right receives Bottom Left
            this.BoardGrid.Get(activeArray.Get(1).Y as Integer).Get(activeArray.Get(1).X as Integer).Z_BlockLogic.BlockType = manipulateArray.Get(0);
        }
        else
        {
            // Top Left receives Bottom Left
            this.BoardGrid.Get(activeArray.Get(2).Y as Integer).Get(activeArray.Get(2).X as Integer).Z_BlockLogic.BlockType = manipulateArray.Get(0);
            
            // Top Right receives Top Left
            this.BoardGrid.Get(activeArray.Get(3).Y as Integer).Get(activeArray.Get(3).X as Integer).Z_BlockLogic.BlockType = manipulateArray.Get(2);
            
            // Bottom Right receives Top Right
            this.BoardGrid.Get(activeArray.Get(1).Y as Integer).Get(activeArray.Get(1).X as Integer).Z_BlockLogic.BlockType = manipulateArray.Get(3);
            
            // Bottom Left receives Bottom Right
            this.BoardGrid.Get(activeArray.Get(0).Y as Integer).Get(activeArray.Get(0).X as Integer).Z_BlockLogic.BlockType = manipulateArray.Get(1);
        }
    }
    
    
//
    function DetermineScoreLine():Boolean
    {
        this.ScoreArray = new Array[Real2]();
        
        this.B_FoundSolution = false;
        
        // blockCheck is tested to ensure that the new block being the compared is not the same as the previous color
        // That way, we help the recursion checks not occur for *all* blocks, but only *new* blocks.
        var blockCheck:Enum_BlockType = Enum_BlockType.None;
        
        // Begin checking for a score line only if the left-most column has a block in it.
        for(var y = 0; y < this.I_LevelHeight; ++y)
        {
            if(blockCheck != this.BoardGrid.Get(y).Get(1).Z_BlockLogic.BlockType)
            {
                blockCheck = this.BoardGrid.Get(y).Get(1).Z_BlockLogic.BlockType;
                
                // Clear the array here since this is a brand new attempt to find a line
                this.PathfindingArray = new Array[Real2]();
                
                if( this.BoardGrid.Get(y).Get(1).Z_BlockLogic.BlockType == Enum_BlockType.Block_One_Static ||
                    this.BoardGrid.Get(y).Get(1).Z_BlockLogic.BlockType == Enum_BlockType.Block_Two_Static)
                    {
                        this.PathfindingArray.Push(Real2(1, y));
                        
                        if(this.ScoreLine(Enum_MoveDirection.Right))
                        {
                            return true;
                        }
                    }
            }
        }
        return false;
    }
//
    function ScoreLine(currDir : Enum_MoveDirection):Boolean
{
    if(this.PathfindingArray.Count >= 29)
    {
        return false;
    }
    
        // We need to initiate a check to ensure every line has at least one block in it first.
        // This was changed from (this.LevelWidth - 1, i >= 0) into the current form due to the side wall mechanic.
        for(var i = this.I_LevelWidth - 2; i >= 1; --i)
        {
            if(this.BoardGrid.Get(0).Get(i).Z_BlockLogic.BlockType == Enum_BlockType.None)
            {
                return false;
            }
        }
    
        // Start with the last position in the array
        var currPos:Real2 = this.PathfindingArray.Get(this.PathfindingArray.Count - 1);
        
        // Check the x coordinate of the current position to determine if we are done
        // This was changed from (this.I_LevelWidth as Integer - 1) due to the side wall mechanic
        if(currPos.X == this.I_LevelWidth as Integer - 2)
        {
            for(var i = 0; i < this.PathfindingArray.Count; ++i)
            {
                this.ScoreArray.Push(this.PathfindingArray.Get(i));
            }
            
            this.ApplyScore(this.ScoreArray);
            
            this.PauseReason = Enum_PauseReason.ScoreLine;
            
            this.B_AllowedToCheck = true;
            
            return true;
        }
        else // We have determined that we need to continue down the line
        {
            var blockType = this.BoardGrid.Get(currPos.Y as Integer).Get(currPos.X as Integer).Z_BlockLogic.BlockType;
            
            // Begin the check process to determine what locations to check
            // Now that we have the initial position to check against, we find all touching locations
            var rightFilled:Boolean = false;
            var belowFilled:Boolean = false;
            var aboveFilled:Boolean = false;
            var leftFilled:Boolean  = false;
            
            // If the space to the right exists AND
            // If the space to the right has the same block type AND
            // We are searching anywhere but where we came from
            if( currPos.X as Integer + 1 < this.I_LevelWidth &&
                this.BoardGrid.Get(currPos.Y as Integer).Get(currPos.X as Integer + 1).Z_BlockLogic.BlockType == blockType &&
                currDir != Enum_MoveDirection.Left)
            {
                rightFilled = true;
            }
            
            // If the space below exists AND
            // If the space below has the same block type AND
            // We are searching anywhere but where we came from
            if( currPos.Y as Integer - 1 >= 0 &&
                this.BoardGrid.Get(currPos.Y as Integer - 1).Get(currPos.X as Integer).Z_BlockLogic.BlockType == blockType &&
                currDir != Enum_MoveDirection.Up)
            {
                belowFilled = true;
            }
            
            // If the space above exists AND
            // If the space above has the same block type AND
            // We are searching anywhere but where we came from
            if( (currPos.Y as Integer + 1) < this.I_LevelHeight &&
                this.BoardGrid.Get(currPos.Y as Integer + 1).Get(currPos.X as Integer).Z_BlockLogic.BlockType == blockType &&
                currDir != Enum_MoveDirection.Down)
            {
                aboveFilled = true;
            }
            
            
            // If the space to the left exists AND
            // If the space to the left has the same block type AND
            // We are searching anywhere but where we came from
            if( currPos.X as Integer - 1 >= 0 &&
                this.BoardGrid.Get(currPos.Y as Integer).Get(currPos.X as Integer - 1).Z_BlockLogic.BlockType == blockType &&
                currDir != Enum_MoveDirection.Right)
                {
                    leftFilled = true;
                }
                
            var shouldContinue = true;
                
            if(rightFilled)
            {
                var rightAbove:Real2 = Real2(currPos.X as Integer + 1, currPos.Y as Integer + 1);
                var rightBelow:Real2 = Real2(currPos.X as Integer + 1, currPos.Y as Integer - 1);
                
                // Check to see if the adjacent positions to the above spot are within the array EXCEPT the last position
                for(var i = 0; i < this.PathfindingArray.Count; ++i)
                {
                    if( this.PathfindingArray.Get(i) == rightAbove ||
                        this.PathfindingArray.Get(i) == rightBelow ) // Spot above and to the left lies within the array
                    {
                        // Console.WriteLine("At `currPos`, going `currDir`, problem at `this.PathfindingArray.Get(i)`");
                        // return false;
                        shouldContinue = false;
                    }
                }
                
                if(shouldContinue)
                {
                    this.PathfindingArray.Push(Real2(currPos.X as Integer + 1, currPos.Y as Integer));
                    
                    if(this.ScoreLine(Enum_MoveDirection.Right))
                    {
                        return true;
                    }
                }
            }
            
            shouldContinue = true;
            
            // Since the space below is populated, we need to check if it is within the array already
            if(belowFilled)
            {
                var belowLeft:Real2  = Real2(currPos.X as Integer - 1, currPos.Y as Integer - 1);
                var belowRight:Real2 = Real2(currPos.X as Integer + 1, currPos.Y as Integer - 1);
                
                // Check to see if the adjacent positions to the above spot are within the array EXCEPT the last position
                for(var i = 0; i < this.PathfindingArray.Count; ++i)
                {
                    if( this.PathfindingArray.Get(i) == belowLeft ||
                        this.PathfindingArray.Get(i) == belowRight ) // Spot above and to the left lies within the array
                    {
                        // Console.WriteLine("At `currPos`, going `currDir`, problem at `this.PathfindingArray.Get(i)`");
                        // return false;
                        shouldContinue = false;
                    }
                }
                
                if(shouldContinue)
                {
                    this.PathfindingArray.Push(Real2(currPos.X as Integer, currPos.Y as Integer - 1));
                    
                    if(this.ScoreLine(Enum_MoveDirection.Down))
                    {
                        return true;
                    }
                }
            }
            
            shouldContinue = true;
            
            if(aboveFilled)
            {
                var aboveLeft:Real2  = Real2(currPos.X as Integer - 1, currPos.Y as Integer + 1);
                var aboveRight:Real2 = Real2(currPos.X as Integer + 1, currPos.Y as Integer + 1);
                
                // Check to see if the adjacent positions to the above spot are within the array EXCEPT the last position
                for(var i = 0; i < this.PathfindingArray.Count; ++i)
                {
                    if( this.PathfindingArray.Get(i) == aboveLeft ||
                        this.PathfindingArray.Get(i) == aboveRight ) // Spot above and to the left lies within the array
                    {
                        shouldContinue = false;
                    }
                }
                
                if(shouldContinue)
                {
                    this.PathfindingArray.Push(Real2(currPos.X as Integer, currPos.Y as Integer + 1));
                    if(this.ScoreLine(Enum_MoveDirection.Up))
                    {
                        return true;
                    }
                }
            }
            
            shouldContinue = true;
            
            if(leftFilled)
            {
                var leftAbove:Real2 = Real2(currPos.X as Integer - 1, currPos.Y as Integer + 1);
                var leftBelow:Real2 = Real2(currPos.X as Integer - 1, currPos.Y as Integer - 1);
                
                // Check to see if the adjacent positions to the above spot are within the array EXCEPT the last position
                for(var i = 0; i < this.PathfindingArray.Count; ++i)
                {
                    if( this.PathfindingArray.Get(i) == leftAbove ||
                        this.PathfindingArray.Get(i) == leftBelow ) // Spot above and to the left lies within the array
                    {
                        // Console.WriteLine("At `currPos`, going `currDir`, problem at `this.PathfindingArray.Get(i)`");
                        shouldContinue = false;
                    }
                }
                
                if(shouldContinue)
                {
                    this.PathfindingArray.Push(Real2(currPos.X as Integer - 1, currPos.Y as Integer));
                    
                    if(this.ScoreLine(Enum_MoveDirection.Left))
                    {
                        return true;
                    }
                }
            }
        }
        this.PathfindingArray.Pop();
        
        return false;
    }

    
//
    function ApplyScore(scoreLine : Array[Real2])
    {
        var xLoc = 0;
        var arrayLength = scoreLine.Count;
        // Reverse through the array to find the first instance where x == 1)
        for(var i = scoreLine.Count - 1; i > 0; --i)
        {
            if(scoreLine.Get(i).X == 1)
            {
                xLoc = i;
                break;
            }
        }
        
        for(var j = 0; j < xLoc; ++j)
        {
            scoreLine.RemoveAt(0);
        }
        
        // Give the player score according to the length of the array
        this.I_Score += scoreLine.Count;
        this.I_SpeedUpBasedOnScore += scoreLine.Count;
        
        for(var i = 0; i < scoreLine.Count; ++i)
        {
            this.GameSession.DispatchEvent("IncrementScore", new Event());
        }
        
        this.ScoreCheck += scoreLine.Count;
        
        for(var i = 0; i < (this.ScoreCheck / this.ScoreToAddBoost); ++i)
        {
            this.ScoreCheck -= this.ScoreToAddBoost;
            
            this.GameSession.DispatchEvent("IncrementBoosts", new Event());
            // this.Space.DispatchEvent(Events.IncrementBoosts, new Event());
            this.I_NumBoosts += 1;
        }
        
        if(this.I_SpeedUpBasedOnScore >= 100 && this.B_IsUnlimitedMode)
        {
            this.I_SpeedUpBasedOnScore -= 100;
            
            if(this.R_BLOCK_TIMER_SECONDS > 0.5)
            {
                
                this.R_BLOCK_TIMER_SECONDS -= 0.15;
            }
            else
            {
                this.R_BLOCK_TIMER_SECONDS = 0.5;
            }
            Console.WriteLine("Reduced Block Timer to: `this.R_BLOCK_TIMER_SECONDS`");
        }
    }
    
//
    function ClearBoard(colorToKill : Enum_BlockType)
    {
        for(var y = 0; y < this.I_LevelHeight; ++y)
        {
            for(var x = 0; x < this.I_LevelWidth; ++x)
            {
                if(this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == colorToKill)
                {
                    this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType = Enum_BlockType.None;
                }
            }
        }
    }
//
    function ConvertBlocks(blockX : Integer, blockY : Integer)
    {
        this.BoardGrid.Get(blockY).Get(blockX).Z_BlockLogic.BlockType = Enum_BlockType.GameOver;
    }
//
    function OnLogicUpdate(event : UpdateEvent)
    {
        if(this.Space.TimeSpace.Paused)
        {
            return;
        }
        
        this.R_Timer += event.Dt;
        this.R_ButtonTimer += event.Dt;
        
        if(this.SoundArray.Get(0) != null)
        {
            for(var i = 0; i < this.SoundArray.Count; ++i)
            {
                if(!this.SoundArray.Get(i).SoundEmitter.IsPlaying())
                {
                    this.SoundArray.Get(i).Destroy();
                    --i;
                }
            }
        }
        
        if(this.PauseReason == Enum_PauseReason.None) // Game is playing
        {
            // Check to see if the game condition is complete
            this.ChallengeWinCondition();
            
            if(this.B_AllowedToCheck)
            {
                this.B_AllowedToCheck = this.DetermineScoreLine();
            }
            
            // Cheat Codes
            if(Zero.Keyboard.KeyIsPressed(Keys.O))
            {
                for(var y = 0; y < 3; ++y)
                {
                    for(var x = 1; x < this.I_LevelWidth - 1; ++x)
                    {
                        this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType = Enum_BlockType.Block_One_Static;
                    }
                }
                this.ConsolidateBlocks();
            }
            
            if(Zero.Keyboard.KeyIsPressed(Keys.P))
            {
                this.I_NumBoosts += 1;
                var incrementBoosts = new IncrementBoosts();
                this.GameSession.DispatchEvent(Events.IncrementBoosts, new Event());
            }
            
            if(this.R_Timer >= this.R_BLOCK_TIMER_SECONDS)
            {
                this.MoveBlocks(Enum_MoveDirection.Down);
                // Resetting the timer occurs within MoveBlocks
            }
            
            if(Zero.Keyboard.KeyIsPressed(Keys.Down) && this.B_AllowedToMoveBlocks)
            {
                this.MoveBlocks(Enum_MoveDirection.Down);
            }
            else if(Zero.Keyboard.KeyIsDown(Keys.Down) && this.B_AllowedToMoveBlocks)
            {
                if(this.R_ButtonTimer >= 0.3)
                {
                    this.MoveBlocks(Enum_MoveDirection.Down);
                }
            }
            else if(Zero.Keyboard.KeyIsPressed(Keys.Left) && this.B_AllowedToMoveBlocks)
            {
                this.MoveBlocks(Enum_MoveDirection.Left);
                
                var blockMove = this.Space.Create(Archetype.Find("SFX_MoveBlock"));
                blockMove.SoundEmitter.Play();
            }
            else if(Zero.Keyboard.KeyIsPressed(Keys.Right) && this.B_AllowedToMoveBlocks)
            {
                this.MoveBlocks(Enum_MoveDirection.Right);
                
                var blockMove = this.Space.Create(Archetype.Find("SFX_MoveBlock"));
                blockMove.SoundEmitter.Play();
            }
            else if(Zero.Keyboard.KeyIsPressed(Keys.Q))
            {
                this.RotateBlocks(true);
                
                var rotateBlock = this.Space.Create(Archetype.Find("SFX_RotateBlock"));
                rotateBlock.SoundEmitter.Play();
            }
            else if(Zero.Keyboard.KeyIsPressed(Keys.E))
            {
                this.RotateBlocks(false);
                
                var rotateBlock = this.Space.Create(Archetype.Find("SFX_RotateBlock"));
                rotateBlock.SoundEmitter.Play();
            }
            else if(Zero.Keyboard.KeyIsPressed(Keys.Up))
            {
                this.RotateBlocks(true);
            }
            else if(Zero.Keyboard.KeyIsPressed(Keys.Space))
            {
                this.AllBlocksStatic();
                this.R_Timer = 0;
            }
            else if(Zero.Keyboard.KeyIsDown(Keys.Left) && this.B_AllowedToMoveBlocks)
            {
                if(this.R_ButtonTimer >= 0.3)
                {
                    this.MoveBlocks(Enum_MoveDirection.Left);
                }
            }
            else if(Zero.Keyboard.KeyIsDown(Keys.Right) && this.B_AllowedToMoveBlocks)
            {
                if(this.R_ButtonTimer >= 0.3)
                {
                    this.MoveBlocks(Enum_MoveDirection.Right);
                }
            }
            else if(!Zero.Keyboard.KeyIsDown(Keys.Left) && !Zero.Keyboard.KeyIsDown(Keys.Right) && !Zero.Keyboard.KeyIsDown(Keys.Down))
            {
                this.R_ButtonTimer = 0;
                this.B_AllowedToMoveBlocks = true;
            }
            
            if(Zero.Keyboard.KeyIsPressed(Keys.A))
            {
                if(this.I_NumBoosts > 0)
                {
                    this.GameSession.DispatchEvent(Events.DecrementBoosts, new Event());
                    
                    this.PauseReason = Enum_PauseReason.BoostUsed;
                    this.BoostType = Enum_BlockType.Block_One_Static;
                    
                    this.BoostArray = new Array[Real2]();
                
                    // Create array of blocks to destroy
                    for(var y = 0; y < this.I_LevelHeight; ++y)
                    {
                        for(var x = 0; x < this.I_LevelWidth; ++x)
                        {
                            if(this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == this.BoostType)
                            {
                                this.BoostArray.Push(Real2(x, y));
                            }
                        }
                    } // End BoostArray
                }
            }
            if(Zero.Keyboard.KeyIsPressed(Keys.D))
            {
                if(this.I_NumBoosts > 0)
                {
                    this.GameSession.DispatchEvent(Events.DecrementBoosts, new Event());
                    
                    this.PauseReason = Enum_PauseReason.BoostUsed;
                    this.BoostType = Enum_BlockType.Block_Two_Static;
                    
                    this.BoostArray = new Array[Real2]();
                
                    // Create array of blocks to destroy
                    for(var y = 0; y < this.I_LevelHeight; ++y)
                    {
                        for(var x = 0; x < this.I_LevelWidth; ++x)
                        {
                            if(this.BoardGrid.Get(y).Get(x).Z_BlockLogic.BlockType == this.BoostType)
                            {
                                this.BoostArray.Push(Real2(x, y));
                            }
                        }
                    }
                    
                } // End If
            }
            
        }
        else if(this.PauseReason == Enum_PauseReason.GameBegin) // Game is Paused (Due to destroying blocks or game is over)
        {
            var randMusic = this.Rand.DieRoll(4);
            if(randMusic == 1)
            {
                this.GameSession.DispatchEvent(Events.LoadTheme_One, new Event());
            }
            else if(randMusic == 2)
            {
                this.GameSession.DispatchEvent(Events.LoadTheme_Two, new Event());
            }
            else if(randMusic == 3)
            {
                this.GameSession.DispatchEvent(Events.LoadTheme_Three, new Event());
            }
            else
            {
                this.GameSession.DispatchEvent(Events.LoadTheme_Four, new Event());
            }
            
            var incrementBoosts = new IncrementBoosts();
            
            for(var i = 0; i < this.I_NumBoosts; ++i)
            {
                this.GameSession.DispatchEvent(Events.IncrementBoosts, new Event());
            }
            
            this.Create2x2();
            
            this.PauseReason = Enum_PauseReason.None;
        }
        // Score a line
        else if(this.PauseReason == Enum_PauseReason.ScoreLine)
        {
            if(this.R_Timer >= 0.06)
            {
                if(this.I_PathfindingCheck < (this.ScoreArray.Count))
                {
                    var blockX = this.ScoreArray.Get(this.I_PathfindingCheck).X;
                    var blockY = this.ScoreArray.Get(this.I_PathfindingCheck).Y;
                    
                    // Play the sound effect attached to the block
                    var soundEffect = this.BoardGrid.Get(blockY as Integer).Get(blockX as Integer).SoundEmitter;
                    soundEffect.Pitch = 0.5 + ((blockY + blockX) * 0.1);
                    // soundEffect.Pitch = 0.5 + ((blockY) * 0.1);
                    soundEffect.Play();
                    // this.BoardGrid.Get(blockY as Integer).Get(blockX as Integer).SoundEmitter.Play();
                    
                    this.ConvertBlocks(blockX as Integer, blockY as Integer);
                    this.I_PathfindingCheck += 1;
                    this.R_Timer = 0;
                }
                else
                {
                    // Clear the blocks from the field
                    // For the length of the scoreLine array, find each individual block and delete it from the BoardGrid
                    for(var i = 0; i < this.ScoreArray.Count; ++i)
                    {
                        this.BoardGrid.Get(this.ScoreArray.Get(i).Y as Integer).Get(this.ScoreArray.Get(i).X as Integer).Z_BlockLogic.BlockType = Enum_BlockType.None;
                    }
                    
                    this.PathfindingArray = new Array[Real2]();
                    this.ScoreArray = new Array[Real2]();
                    
                    this.I_PathfindingCheck = 0;
                    
                    this.ConsolidateBlocks();
                    
                    //if(this.I_Score >= 750 && this.ScoreArray.Count == 0)
                    //{
                    //    this.I_GO_X = 1;
                    //    this.I_GO_Y = 0;
                    //    this.R_Timer = 0;
                    //    this.PauseReason = Enum_PauseReason.WinGame;
                    //}
                    //else
                    //{
                    //    this.PauseReason = Enum_PauseReason.None;
                    //}
                    
                    this.PauseReason = Enum_PauseReason.None;
                }
            }
        }
        // Boost was used
        else if(this.PauseReason == Enum_PauseReason.BoostUsed)
        {
            this.B_AllowedToCheck = true;
            
            if(this.R_Timer >= 0.05)
            {
                if(this.I_PathfindingCheck < this.BoostArray.Count)
                {
                    if(this.I_PathfindingCheck % 2 == 0)
                    {
                        var explosionSound = this.Space.Create(Archetype.Find("Sound_Explosion"));
                        explosionSound.SoundEmitter.Play();
                    }
                    
                    this.BoardGrid.Get(this.BoostArray.Get(this.I_PathfindingCheck).Y as Integer).Get(this.BoostArray.Get(this.I_PathfindingCheck).X as Integer).Z_BlockLogic.BlockType = Enum_BlockType.None;
                    
                    // Place explosion here
                    this.BoardGrid.Get(this.BoostArray.Get(this.I_PathfindingCheck).Y as Integer).Get(this.BoostArray.Get(this.I_PathfindingCheck).X as Integer).FindChildByName("FireParticleEffect").SphericalParticleEmitter.ResetCount();
                    this.BoardGrid.Get(this.BoostArray.Get(this.I_PathfindingCheck).Y as Integer).Get(this.BoostArray.Get(this.I_PathfindingCheck).X as Integer).FindChildByName("FireParticleEffect").SphericalParticleEmitter.Active = true;
                    
                    this.I_PathfindingCheck += 1;
                    this.R_Timer = 0;
                }
                else
                {
                    if(this.R_Timer >= 1.0)
                    {
                        this.I_PathfindingCheck = 0;
                    
                        this.ConsolidateBlocks();
                        
                        this.I_NumBoosts -= 1;
                        
                        this.PauseReason = Enum_PauseReason.None;
                        this.R_Timer = 0;
                    }
                }
            }
        } // End B_BoostUsed
        else if(this.PauseReason == Enum_PauseReason.WinGame)
        {
            if(this.I_GO_Y == this.I_LevelHeight - 1 && this.I_GO_X == this.I_LevelWidth - 1)
            {
                if(this.BoardGrid.Get(this.I_LevelHeight - 1).Get(this.I_LevelWidth - 1).Z_BlockLogic.BlockType != Enum_BlockType.Block_Two_Active)
                {
                    this.BoardGrid.Get(this.I_LevelHeight - 1).Get(this.I_LevelWidth - 1).Z_BlockLogic.BlockType = Enum_BlockType.Block_Two_Active;
                }
                
                if(this.R_Timer >= 3.0)
                {
                    this.SaveStarArray();
                    this.GoToScoreboard();
                }
            }
            else
            {
                if(this.R_Timer >= 0.1)
                {
                    if(this.I_GO_X >= this.I_LevelWidth - 1)
                    {
                        if(this.I_GO_Y + 1 < this.I_LevelHeight)
                        {
                            ++this.I_GO_Y;
                        }
                        this.I_GO_X = 1;
                    }
                    
                    // Even numbered layers
                    if(this.I_GO_X % 2 == 0)
                    {
                        if(this.I_GO_Y % 2 == 0)
                        {
                            this.BoardGrid.Get(this.I_GO_Y).Get(this.I_GO_X).Z_BlockLogic.BlockType = Enum_BlockType.Block_One_Static;
                        }
                        else
                        {
                            this.BoardGrid.Get(this.I_GO_Y).Get(this.I_GO_X).Z_BlockLogic.BlockType = Enum_BlockType.Block_Two_Static;
                        }
                    }
                    else
                    {
                        if(this.I_GO_Y % 2 == 0)
                        {
                            this.BoardGrid.Get(this.I_GO_Y).Get(this.I_GO_X).Z_BlockLogic.BlockType = Enum_BlockType.Block_Two_Static;
                        }
                        else
                        {
                            this.BoardGrid.Get(this.I_GO_Y).Get(this.I_GO_X).Z_BlockLogic.BlockType = Enum_BlockType.Block_One_Static;
                        }
                    }
                    
                    ++this.I_GO_X;
                }
            }
        } // End WinGame
        else if(this.PauseReason == Enum_PauseReason.GameOver)
        {
            
            if( this.I_GO_X >= (this.I_LevelWidth - 2) &&
                this.I_GO_Y >= (this.I_LevelHeight - 1) )
                {
                    // Purposefully breaking out to avoid a crash for now
                    this.ConvertBlocks(this.I_GO_X, this.I_GO_Y);
                    
                    if(this.R_Timer >= 3.0)
                    {
                        this.GoToScoreboard();
                    }
                    
                }
            else if(this.R_Timer > 0.01)
            {
                this.ConvertBlocks(this.I_GO_X, this.I_GO_Y);
                
                // We move horizontally to replace each block with a Game Over block.
                ++this.I_GO_X;
                
                // When we reach the end of a layer, we increment a layer and start over, horizontally
                if(this.I_GO_X >= this.I_LevelWidth - 1)
                {
                    if(this.I_GO_Y < this.I_LevelHeight)
                    {
                        ++this.I_GO_Y;
                        this.I_GO_X = 1;
                    }
                }
                // Reset the timer
                this.R_Timer = 0;
            }
        } // End B_GameOver
    }
//
    function OnTimerGameOver(event : Event)
    {
        this.GameSession.DispatchEvent(Events.HUDTimer_GameOver, new Event());
        this.PauseReason = Enum_PauseReason.WinGame;
    }
//
    function GoToScoreboard()
    {
        while(this.GameSession.FindSpaceByName("LevelSpace") != null)
        {
            this.GameSession.FindSpaceByName("LevelSpace").Destroy();
        }
        
        while(this.GameSession.FindSpaceByName("ThemeSpace") != null)
        {
            this.GameSession.FindSpaceByName("ThemeSpace").Destroy();
        }
        
        while(this.GameSession.FindSpaceByName("HudSpace") != null)
        {
            this.GameSession.FindSpaceByName("HudSpace").Destroy();
        }
        
        var levelSpace = this.GameSession.CreateNamedSpace("LevelSpace", Archetype.Find("Space"));
        
        var gameLevel  = Level.Find("Menu_Challenge");
        // Kept this here so only one levelspace is created
        levelSpace = this.GameSession.FindSpaceByName("LevelSpace");
        levelSpace.LoadLevel(gameLevel);
        
        if(this.GameSession.FindSpaceByName("Main") != null)
        {
            this.GameSession.FindSpaceByName("Main").Destroy();
        }
        
        // Recreating details since they were destroyed above
        // this.ScoreboardSpace = this.GameSession.CreateNamedSpace("LevelSpace", Archetype.Find("Space"));
        // this.ScoreboardLevel = Level.Find("Game_Scoreboard");
        // this.ScoreboardSpace = this.GameSession.FindSpaceByName("LevelSpace");
        
        // this.ScoreboardSpace.LoadLevel(this.ScoreboardLevel);
        // this.ScoreboardSpace.LevelSettings.Z_ScoreboardLogic.InitializeScoreboard(this.GameModeType, this.I_Score);
    }
//
    function DetermineGamemodeType(iWidth : Integer, iHeight : Integer, iTimeLengthMinutes : Integer)
    {
        if(iTimeLengthMinutes == 5)
        {
            if(iWidth == 10 && iHeight == 16)
            {
                this.GameModeType = Enum_ScoreboardType.Normal_5;
            }
            else if(iWidth == 13 && iHeight == 13)
            {
                this.GameModeType = Enum_ScoreboardType.Hard_5;
            }
            else if(iWidth == 16 && iHeight == 10)
            {
                this.GameModeType = Enum_ScoreboardType.Extreme_5;
            }
        }
        else if(iTimeLengthMinutes == 10)
        {
            if(iWidth == 10 && iHeight == 16)
            {
                this.GameModeType = Enum_ScoreboardType.Normal_10;
            }
            else if(iWidth == 13 && iHeight == 13)
            {
                this.GameModeType = Enum_ScoreboardType.Hard_10;
            }
            else if(iWidth == 16 && iHeight == 10)
            {
                this.GameModeType = Enum_ScoreboardType.Extreme_10;
            }
        }
        else if(iTimeLengthMinutes == 20)
        {
            if(iWidth == 10 && iHeight == 16)
            {
                this.GameModeType = Enum_ScoreboardType.Normal_20;
            }
            else if(iWidth == 13 && iHeight == 13)
            {
                this.GameModeType = Enum_ScoreboardType.Hard_20;
            }
            else if(iWidth == 16 && iHeight == 10)
            {
                this.GameModeType = Enum_ScoreboardType.Extreme_20;
            }
        }
        else // Time length is unlimited
        {
            if(iWidth == 10 && iHeight == 16)
            {
                this.GameModeType = Enum_ScoreboardType.Normal_Unlimited;
            }
            else if(iWidth == 13 && iHeight == 13)
            {
                this.GameModeType = Enum_ScoreboardType.Hard_Unlimited;
            }
            else if(iWidth == 16 && iHeight == 10)
            {
                this.GameModeType = Enum_ScoreboardType.Extreme_Unlimited;
            }
        }
    }
//
}
